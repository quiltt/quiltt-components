import { gql } from '@apollo/client'
import * as Apollo from '@apollo/client'

export type Maybe<T> = T | null
export type Exact<T extends { [key: string]: unknown }> = {
  [K in keyof T]: T[K]
}
export type MakeOptional<T, K extends keyof T> = Omit<T, K> &
  { [SubKey in K]?: Maybe<T[SubKey]> }
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> &
  { [SubKey in K]: Maybe<T[SubKey]> }

/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string
  String: string
  Boolean: boolean
  Int: number
  Float: number
  /** Represents an ISO 8601-encoded date */
  Date: any
  /** Represents an ISO 8601-encoded datetime */
  DateTime: any
  /** Represents untyped JSON */
  JSON: any
  /** A valid URL, transported as a string */
  URL: any
}

/** Represents an Account */
export type Account = {
  __typename?: 'Account'
  /** Balance */
  balance: LedgerBalance
  /** Bills last paid from this account */
  bills: Array<Bill>
  /** ID */
  id: Scalars['ID']
  /** Last 4 numbers */
  lastFourDigits?: Maybe<Scalars['String']>
  /** Customizable metadata */
  metadata?: Maybe<Scalars['JSON']>
  /** Name */
  name: Scalars['String']
  /** Plaid Item account belongs to */
  plaidItem?: Maybe<PlaidItem>
  /** API Data Source */
  source?: Maybe<SourceAccounts>
  /** API Data Sources */
  sources?: Maybe<Array<SourceAccounts>>
  /** Status */
  status: LedgerStatus
  /** A limited list of transactions. Use `transactionsConnection` for a full paginated list. */
  transactions: Array<Transaction>
  /** Cursor-based pagination transactions */
  transactionsConnection: TransactionConnection
  /** Account type */
  type: AccountTypes
}

/** Represents an Account */
export type AccountSourceArgs = {
  type: SourceTypes
}

/** Represents an Account */
export type AccountSourcesArgs = {
  types?: Maybe<Array<SourceTypes>>
}

/** Represents an Account */
export type AccountTransactionsArgs = {
  filter?: Maybe<TransactionFilter>
  limit?: Scalars['Int']
  sort?: Maybe<TransactionSort>
}

/** Represents an Account */
export type AccountTransactionsConnectionArgs = {
  after?: Maybe<Scalars['String']>
  before?: Maybe<Scalars['String']>
  filter?: Maybe<TransactionFilter>
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
  sort?: Maybe<TransactionSort>
}

/** Represents the classification of an Account */
export enum AccountTypes {
  /** Traditional checking and cash management accounts */
  Checking = 'CHECKING',
  /** Credit card accounts */
  Credit = 'CREDIT',
  /** Brokerage, retirement and CD accounts */
  Investment = 'INVESTMENT',
  /** Lines of credit, mortgage, student and installment loans */
  Loan = 'LOAN',
  /** Mortgage */
  Mortgage = 'MORTGAGE',
  /** All other accounts */
  Other = 'OTHER',
  /** Traditional savings and money market accounts */
  Savings = 'SAVINGS',
}

/** Autogenerated input type of AccountUpdate */
export type AccountUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  id: Scalars['ID']
  /** Customizable metadata */
  metadata?: Maybe<Scalars['JSON']>
}

/** Autogenerated return type of AccountUpdate */
export type AccountUpdatePayload = {
  __typename?: 'AccountUpdatePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** List of errors from mutation */
  errors?: Maybe<Array<Error>>
  /** Updated Account Information */
  record?: Maybe<Account>
  /** Status of the mutation */
  success: Scalars['Boolean']
}

/** Represents a recurring expense */
export type Bill = {
  __typename?: 'Bill'
  account?: Maybe<Account>
  amount?: Maybe<Scalars['Float']>
  /** Balance */
  balance: LedgerBalance
  category?: Maybe<Category>
  frequency?: Maybe<RecurrenceFrequency>
  /** ID */
  id: Scalars['ID']
  merchant?: Maybe<Merchant>
  name: Scalars['String']
  /** Date of next occurence */
  nextPaymentDate?: Maybe<Scalars['Date']>
  /** Status */
  status: LedgerStatus
  /** A limited list of transactions. Use `transactionsConnection` for a full paginated list. */
  transactions: Array<Transaction>
  /** Cursor-based pagination transactions */
  transactionsConnection: TransactionConnection
}

/** Represents a recurring expense */
export type BillBalanceArgs = {
  filter?: Maybe<TransactionFilter>
}

/** Represents a recurring expense */
export type BillTransactionsArgs = {
  filter?: Maybe<TransactionFilter>
  limit?: Scalars['Int']
  sort?: Maybe<TransactionSort>
}

/** Represents a recurring expense */
export type BillTransactionsConnectionArgs = {
  after?: Maybe<Scalars['String']>
  before?: Maybe<Scalars['String']>
  filter?: Maybe<TransactionFilter>
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
  sort?: Maybe<TransactionSort>
}

/** Autogenerated input type of BillCreate */
export type BillCreateInput = {
  amount: Scalars['Float']
  categoryId?: Maybe<Scalars['ID']>
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  dueDate?: Maybe<Scalars['Date']>
  frequency: RecurrenceFrequency
  merchantId?: Maybe<Scalars['ID']>
  name: Scalars['String']
}

/** Autogenerated return type of BillCreate */
export type BillCreatePayload = {
  __typename?: 'BillCreatePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** List of errors from mutation */
  errors?: Maybe<Array<Error>>
  /** Updated bill */
  record?: Maybe<Bill>
  /** Status of the mutation */
  success: Scalars['Boolean']
}

/** Autogenerated input type of BillUpdate */
export type BillUpdateInput = {
  amount?: Maybe<Scalars['Float']>
  categoryId?: Maybe<Scalars['ID']>
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  dueDate?: Maybe<Scalars['Date']>
  frequency?: Maybe<RecurrenceFrequency>
  id: Scalars['ID']
  merchantId?: Maybe<Scalars['ID']>
  name?: Maybe<Scalars['String']>
  rejectedAt?: Maybe<Scalars['DateTime']>
}

/** Autogenerated return type of BillUpdate */
export type BillUpdatePayload = {
  __typename?: 'BillUpdatePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** List of errors from mutation */
  errors?: Maybe<Array<Error>>
  /** Updated bill */
  record?: Maybe<Bill>
  /** Status of the mutation */
  success: Scalars['Boolean']
}

/** Represents a Quiltt Category */
export type Category = {
  __typename?: 'Category'
  description?: Maybe<Scalars['String']>
  emoji?: Maybe<Scalars['String']>
  emojiName: Scalars['String']
  /** ID */
  id: Scalars['ID']
  name: Scalars['String']
}

/** Represents an Error */
export type Error = {
  __typename?: 'Error'
  /** Error Message */
  message?: Maybe<Scalars['String']>
  /** Object path for error */
  path?: Maybe<Array<Scalars['String']>>
}

/** Represents an image */
export type Image = {
  __typename?: 'Image'
  /** URL for the image */
  url?: Maybe<Scalars['URL']>
}

export type LedgerBalance = {
  __typename?: 'LedgerBalance'
  /** The amount of funds including pending transactions */
  available?: Maybe<Scalars['Float']>
  /** The amount of funds based on posted transactions */
  current?: Maybe<Scalars['Float']>
  /** Cache Key */
  id: Scalars['ID']
  /** The amount of funds that may be overdraft or spent on credit */
  limit?: Maybe<Scalars['Float']>
}

export enum LedgerStatus {
  /** Active */
  Active = 'ACTIVE',
  /** Terminated */
  Closed = 'CLOSED',
  /** Duplicate or disabled */
  Hidden = 'HIDDEN',
  /** Automation disabled */
  Paused = 'PAUSED',
}

/** Represents a Merchant */
export type Merchant = {
  __typename?: 'Merchant'
  /** ID */
  id: Scalars['ID']
  name: Scalars['String']
}

/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type Mutation = {
  __typename?: 'Mutation'
  /** Update Account Information */
  accountUpdate?: Maybe<AccountUpdatePayload>
  billCreate?: Maybe<BillCreatePayload>
  billUpdate?: Maybe<BillUpdatePayload>
  /** Create a Plaid Item from a successful Link submission */
  plaidItemCreate?: Maybe<PlaidItemCreatePayload>
  /** Delete a Plaid Item */
  plaidItemDelete?: Maybe<PlaidItemDeletePayload>
  /** Create a Link token to configure an instance of Link */
  plaidLinkTokenCreate?: Maybe<PlaidLinkTokenCreatePayload>
  /** Create a Link token to configure an instance of Link in Update Mode */
  plaidLinkTokenCreateForUpdate?: Maybe<PlaidLinkTokenCreateForUpdatePayload>
  /** Create a Plaid Processor token suitable for sending to one of Plaid's integration partners */
  plaidProcessorTokenCreate?: Maybe<PlaidProcessorTokenCreatePayload>
  /** Update Profile Information */
  profileUpdate?: Maybe<ProfileUpdatePayload>
  /** Create a RoundUp */
  roundUpCreate?: Maybe<RoundUpCreatePayload>
  /** Pause a RoundUp */
  roundUpPause?: Maybe<RoundUpPausePayload>
  /** Resume a RoundUp */
  roundUpResume?: Maybe<RoundUpResumePayload>
  /** Set the funding account for a RoundUp */
  roundUpSetFundingAccount?: Maybe<RoundUpSetFundingAccountPayload>
  /** Set the RoundUp start time */
  roundUpSetStartTime?: Maybe<RoundUpSetStartTimePayload>
  /** Add Accounts to a RoundUp */
  roundUpSubscribedAccountsAdd?: Maybe<RoundUpSubscribedAccountsAddPayload>
  /** Remove Accounts from a RoundUp */
  roundUpSubscribedAccountsRemove?: Maybe<RoundUpSubscribedAccountsRemovePayload>
  /** Update Transaction Information */
  transactionUpdate?: Maybe<TransactionUpdatePayload>
}

/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationAccountUpdateArgs = {
  input: AccountUpdateInput
}

/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationBillCreateArgs = {
  input: BillCreateInput
}

/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationBillUpdateArgs = {
  input: BillUpdateInput
}

/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationPlaidItemCreateArgs = {
  input: PlaidItemCreateInput
}

/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationPlaidItemDeleteArgs = {
  input: PlaidItemDeleteInput
}

/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationPlaidLinkTokenCreateArgs = {
  input: PlaidLinkTokenCreateInput
}

/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationPlaidLinkTokenCreateForUpdateArgs = {
  input: PlaidLinkTokenCreateForUpdateInput
}

/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationPlaidProcessorTokenCreateArgs = {
  input: PlaidProcessorTokenCreateInput
}

/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationProfileUpdateArgs = {
  input: ProfileUpdateInput
}

/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationRoundUpCreateArgs = {
  input: RoundUpCreateInput
}

/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationRoundUpPauseArgs = {
  input: RoundUpPauseInput
}

/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationRoundUpResumeArgs = {
  input: RoundUpResumeInput
}

/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationRoundUpSetFundingAccountArgs = {
  input: RoundUpSetFundingAccountInput
}

/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationRoundUpSetStartTimeArgs = {
  input: RoundUpSetStartTimeInput
}

/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationRoundUpSubscribedAccountsAddArgs = {
  input: RoundUpSubscribedAccountsAddInput
}

/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationRoundUpSubscribedAccountsRemoveArgs = {
  input: RoundUpSubscribedAccountsRemoveInput
}

/** The top-level Mutation type. Mutations are used to make requests that create or modify data. */
export type MutationTransactionUpdateArgs = {
  input: TransactionUpdateInput
}

/** Information about pagination in a connection. */
export type PageInfo = {
  __typename?: 'PageInfo'
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['String']>
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean']
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean']
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['String']>
}

/** Represents a Plaid API Error */
export type PlaidApiError = {
  __typename?: 'PlaidAPIError'
  /** The particular error code */
  code: Scalars['String']
  /** A user-friendly representation of the error code */
  displayMessage?: Maybe<Scalars['String']>
  /** A developer-friendly representation of the error code */
  message: Scalars['String']
  /** A unique identifying the request, to be used for troubleshooting purposes */
  requestId?: Maybe<Scalars['String']>
  /** A broad categorization of the error */
  type: Scalars['String']
}

/** Plaid Account Data */
export type PlaidAccount = {
  __typename?: 'PlaidAccount'
  /** Plaid’s unique identifier for the account */
  accountId: Scalars['String']
  /** A set of fields describing the balance for an account. */
  balances: PlaidAccountBalances
  /**
   * The last 2-4 alphanumeric characters of an account's official account number.
   * Note that the mask may be non-unique between an Item's accounts, and it may
   * also not match the mask that the bank displays to the user.
   */
  mask?: Maybe<Scalars['String']>
  /** The name of the account, either assigned by the user or by the financial institution itself */
  name: Scalars['String']
  /** The official name of the account as given by the financial institution */
  officialName?: Maybe<Scalars['String']>
  /**
   * Possible values: 401a, 401k, 403B, 457b, 529, brokerage, cash isa, education
   * savings account, gic, health reimbursement arrangement, hsa, isa, ira, lif,
   * lira, lrif, lrsp, non-taxable brokerage account, other, prif, rdsp, resp,
   * rlif, rrif, pension, profit sharing plan, retirement, roth, roth 401k, rrsp,
   * sep ira, simple ira, sipp, stock plan, thrift savings plan, tfsa, trust, ugma,
   * utma, variable annuity, credit card, paypal, cd, checking, savings, money
   * market, prepaid, auto, commercial, construction, consumer, home, home equity,
   * loan, mortgage, overdraft, line of credit, student, cash management, keogh,
   * mutual fund, recurring, rewards, safe deposit, sarsep, null
   */
  subtype?: Maybe<Scalars['String']>
  /** Possible values: investment, credit, depository, loan, brokerage, other */
  type: Scalars['String']
  /**
   * The current verification status of an Auth Item initiated through Automated or
   * Manual micro-deposits.  Returned for Auth Items only.
   * Possible values: pending_automatic_verification, pending_manual_verification,
   * manually_verified, verification_expired, verification_failed
   */
  verificationStatus?: Maybe<Scalars['String']>
}

/** Plaid Account Balances Data */
export type PlaidAccountBalances = {
  __typename?: 'PlaidAccountBalances'
  /** The amount of funds available to be withdrawn from the account, as determined by the financial institution. */
  available?: Maybe<Scalars['Float']>
  /** The total amount of funds in or owed by the account. */
  current: Scalars['Float']
  /** The ISO-4217 currency code of the balance. Always null if unofficial_currency_code is non-null. */
  isoCurrencyCode?: Maybe<Scalars['String']>
  /** For credit-type accounts, this represents the credit limit. */
  limit?: Maybe<Scalars['Float']>
  /**
   * The unofficial currency code associated with the balance. Always null if
   * iso_currency_code is non-null. Unofficial currency codes are used for
   * currencies that do not have official ISO currency codes, such as
   * cryptocurrencies and the currencies of certain countries.
   */
  unofficialCurrencyCode?: Maybe<Scalars['String']>
}

/** Represents a Plaid item */
export type PlaidItem = {
  __typename?: 'PlaidItem'
  /** Accounts */
  accounts: Array<Account>
  /** Number of accounts */
  accountsCount: Scalars['Int']
  /** Plaid Item ID */
  id: Scalars['ID']
  /** Institution logo */
  logo?: Maybe<Image>
  /** Name of the Plaid Item */
  name: Scalars['String']
  /** Item status */
  status: PlaidItemStatus
  /** Last sync time */
  syncedAt?: Maybe<Scalars['DateTime']>
  /** Number of transactions */
  transactionsCount: Scalars['Int']
}

/** Autogenerated input type of PlaidItemCreate */
export type PlaidItemCreateInput = {
  /** An array of UUIDs to use as primary keys for the accounts the user selected during Link */
  accountIds?: Maybe<Array<Scalars['ID']>>
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** The `metadata` object from Plaid Link's `onSuccess` callback */
  metadata: Scalars['JSON']
  /** The `public_token` string from Plaid Link's `onSuccess` callback */
  publicToken: Scalars['String']
}

/** Autogenerated return type of PlaidItemCreate */
export type PlaidItemCreatePayload = {
  __typename?: 'PlaidItemCreatePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** Plaid API Error */
  errors?: Maybe<Array<PlaidApiError>>
  /** Plaid Item */
  record?: Maybe<PlaidItem>
  /** Status of the mutation */
  success: Scalars['Boolean']
}

/** Autogenerated input type of PlaidItemDelete */
export type PlaidItemDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** ID of Plaid Item to delete */
  id: Scalars['ID']
}

/** Autogenerated return type of PlaidItemDelete */
export type PlaidItemDeletePayload = {
  __typename?: 'PlaidItemDeletePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** Plaid API Error */
  errors?: Maybe<Array<PlaidApiError>>
  /** Plaid Item */
  record?: Maybe<PlaidItem>
  /** Status of the mutation */
  success: Scalars['Boolean']
}

/** Represents the sync status of a Plaid Item */
export enum PlaidItemStatus {
  /** Needs reconnecting */
  Disconnected = 'DISCONNECTED',
  /** In an error state */
  Error = 'ERROR',
  /** Successfully synced */
  Synced = 'SYNCED',
  /** Currently syncing */
  Syncing = 'SYNCING',
}

/** Autogenerated return type of PlaidItemUpdated */
export type PlaidItemUpdatedPayload = {
  __typename?: 'PlaidItemUpdatedPayload'
  record?: Maybe<PlaidItem>
}

export type PlaidLinkAccountFiltersCreditAccountSubtypesInput = {
  accountSubtypes: Array<Scalars['String']>
}

export type PlaidLinkAccountFiltersDepositoryAccountSubtypesInput = {
  accountSubtypes: Array<Scalars['String']>
}

export type PlaidLinkAccountFiltersInput = {
  credit?: Maybe<PlaidLinkAccountFiltersCreditAccountSubtypesInput>
  depository?: Maybe<PlaidLinkAccountFiltersDepositoryAccountSubtypesInput>
}

/** Represents a Link token */
export type PlaidLinkToken = {
  __typename?: 'PlaidLinkToken'
  /** Expiration time of the `link_token` */
  expiration: Scalars['DateTime']
  /** A `link_token` that can be supplied to initialize Plaid Link */
  linkToken: Scalars['ID']
}

/** Autogenerated input type of PlaidLinkTokenCreateForUpdate */
export type PlaidLinkTokenCreateForUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** An array of Plaid-supported country codes using ISO-3166-1 alpha-2 country code standard */
  countryCodes?: Maybe<Array<Scalars['String']>>
  /** The language that Link should be displayed in. Defaults to your Quiltt app's default language will be used */
  language?: Maybe<Scalars['String']>
  /** The name of the Link customization from the Plaid Dashboard to be applied to Link */
  linkCustomizationName?: Maybe<Scalars['String']>
  /** The ID of the PlaidItem to update */
  plaidItemId: Scalars['ID']
}

/** Autogenerated return type of PlaidLinkTokenCreateForUpdate */
export type PlaidLinkTokenCreateForUpdatePayload = {
  __typename?: 'PlaidLinkTokenCreateForUpdatePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** Plaid API Error */
  errors?: Maybe<Array<PlaidApiError>>
  /** Link token */
  record?: Maybe<PlaidLinkToken>
  /** Status of the mutation */
  success: Scalars['Boolean']
}

/** Autogenerated input type of PlaidLinkTokenCreate */
export type PlaidLinkTokenCreateInput = {
  accountFilters?: Maybe<PlaidLinkAccountFiltersInput>
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** An array of Plaid-supported country codes using ISO-3166-1 alpha-2 country code standard */
  countryCodes?: Maybe<Array<Scalars['String']>>
  /** The language that Link should be displayed in. Defaults to your Quiltt app's default language will be used */
  language?: Maybe<Scalars['String']>
  /** The name of the Link customization from the Plaid Dashboard to be applied to Link */
  linkCustomizationName?: Maybe<Scalars['String']>
  /** List of products to use with Link */
  products: Array<Scalars['String']>
}

/** Autogenerated return type of PlaidLinkTokenCreate */
export type PlaidLinkTokenCreatePayload = {
  __typename?: 'PlaidLinkTokenCreatePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** Plaid API Error */
  errors?: Maybe<Array<PlaidApiError>>
  /** Link token */
  record?: Maybe<PlaidLinkToken>
  /** Status of the mutation */
  success: Scalars['Boolean']
}

/** Represents a Processor token */
export type PlaidProcessorToken = {
  __typename?: 'PlaidProcessorToken'
  /** The `processor_token` that can then be used by the Plaid partner to make API requests */
  processorToken: Scalars['ID']
}

/** Autogenerated input type of PlaidProcessorTokenCreate */
export type PlaidProcessorTokenCreateInput = {
  /**
   * The Plaid `account_id` obtained from the onSuccess callback in Plaid Link or,
   * the `accountId` from the PlaidAccount source in Quiltt
   */
  accountId: Scalars['ID']
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** The ID of the Plaid Item data is being requested for */
  plaidItemId: Scalars['ID']
  /** The processor you are integrating with */
  processor: Scalars['String']
}

/** Autogenerated return type of PlaidProcessorTokenCreate */
export type PlaidProcessorTokenCreatePayload = {
  __typename?: 'PlaidProcessorTokenCreatePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** Plaid API Error */
  errors?: Maybe<Array<PlaidApiError>>
  /** Processor token */
  record?: Maybe<PlaidProcessorToken>
  /** Status of the mutation */
  success: Scalars['Boolean']
}

/** Plaid Transaction Data */
export type PlaidTransaction = {
  __typename?: 'PlaidTransaction'
  /** The ID of the account in which this transaction occurred. */
  accountId: Scalars['String']
  /** The name of the account owner. This field is not typically populated and only relevant when dealing with sub-accounts. */
  accountOwner?: Maybe<Scalars['String']>
  /**
   * The settled value of the transaction, denominated in the account's currency,
   * as stated in iso_currency_code or unofficial_currency_code. Positive values
   * when money moves out of the account; negative values when money moves in. For
   * example, debit card purchases are positive; credit card payments, direct
   * deposits, and refunds are negative.
   */
  amount: Scalars['Float']
  /** The date that the transaction was authorized. Dates are returned in an ISO 8601 format ( YYYY-MM-DD ). */
  authorizedDate?: Maybe<Scalars['String']>
  /** Date and time when a transaction was authorized in ISO 8601 format ( YYYY-MM-DDTHH:mm:ssZ ). */
  authorizedDatetime?: Maybe<Scalars['String']>
  /** A hierarchical array of the categories to which this transaction belongs. */
  category?: Maybe<Array<Scalars['String']>>
  /** The ID of the category to which this transaction belongs. */
  categoryId: Scalars['String']
  /**
   * For pending transactions, the date that the transaction occurred; for posted
   * transactions, the date that the transaction posted. Both dates are returned in
   * an ISO 8601 format ( YYYY-MM-DD ).
   */
  date: Scalars['Date']
  /** Date and time when a transaction was posted in ISO 8601 format ( YYYY-MM-DDTHH:mm:ssZ ). */
  datetime?: Maybe<Scalars['DateTime']>
  /** The ISO-4217 currency code of the transaction. Always null if unofficial_currency_code is non-null. */
  isoCurrencyCode?: Maybe<Scalars['String']>
  /** A representation of where a transaction took place */
  location: PlaidTransactionLocation
  /** The merchant name, as extracted by Plaid from the name field. */
  merchantName?: Maybe<Scalars['String']>
  /** The merchant name or transaction description. */
  name: Scalars['String']
  /** The channel used to make a payment. Possible values: online, in store, other */
  paymentChannel: Scalars['String']
  /**
   * Transaction information specific to inter-bank transfers. If the transaction
   * was not an inter-bank transfer, all fields will be null.
   */
  paymentMeta: PlaidTransactionPaymentMeta
  /**
   * When true, identifies the transaction as pending or unsettled. Pending
   * transaction details (name, type, amount, category ID) may change before they are settled.
   */
  pending: Scalars['Boolean']
  /** The ID of a posted transaction's associated pending transaction, where applicable. */
  pendingTransactionId?: Maybe<Scalars['String']>
  /**
   * An identifier classifying the transaction type. Possible values: adjustment,
   * atm, bank charge, bill payment, cash, cashback, cheque, direct debit,
   * interest, purchase, standing order, transfer, null
   */
  transactionCode?: Maybe<Scalars['String']>
  /** The unique ID of the transaction. */
  transactionId: Scalars['String']
  /** API Source */
  type: SourceTypes
  /**
   * The unofficial currency code associated with the transaction. Always null if
   * iso_currency_code is non-null. Unofficial currency codes are used for
   * currencies that do not have official ISO currency codes, such as
   * cryptocurrencies and the currencies of certain countries.
   */
  unofficialCurrencyCode?: Maybe<Scalars['String']>
}

/** Plaid Transaction Data */
export type PlaidTransactionLocation = {
  __typename?: 'PlaidTransactionLocation'
  /** The street address where the transaction occurred. */
  address?: Maybe<Scalars['String']>
  /** The city where the transaction occurred. */
  city?: Maybe<Scalars['String']>
  /** The ISO 3166-1 alpha-2 country code where the transaction occurred. */
  country?: Maybe<Scalars['String']>
  /** The latitude where the transaction occurred. */
  lat?: Maybe<Scalars['Float']>
  /** The longitude where the transaction occurred. */
  lon?: Maybe<Scalars['Float']>
  /** The postal code where the transaction occurred. */
  postalCode?: Maybe<Scalars['String']>
  /** The region or state where the transaction occurred. */
  region?: Maybe<Scalars['String']>
  /** The merchant defined store number where the transaction occurred. */
  storeNumber?: Maybe<Scalars['String']>
}

/** Plaid Transaction PaymentMeta Data */
export type PlaidTransactionPaymentMeta = {
  __typename?: 'PlaidTransactionPaymentMeta'
  /** The party initiating a wire transfer. Will be null if the transaction is not a wire transfer. */
  byOrderOf?: Maybe<Scalars['String']>
  /** For transfers, the party that is receiving the transaction. */
  payee?: Maybe<Scalars['String']>
  /** For transfers, the party that is paying the transaction. */
  payer?: Maybe<Scalars['String']>
  /** The type of transfer, e.g. 'ACH' */
  paymentMethod?: Maybe<Scalars['String']>
  /** The name of the payment processor */
  paymentProcessor?: Maybe<Scalars['String']>
  /** The ACH PPD ID for the payer. */
  ppdId?: Maybe<Scalars['String']>
  /** The payer-supplied description of the transfer. */
  reason?: Maybe<Scalars['String']>
  /** The transaction reference number supplied by the financial institution. */
  referenceNumber?: Maybe<Scalars['String']>
}

/** Represents a Profile */
export type Profile = {
  __typename?: 'Profile'
  /** Email */
  email?: Maybe<Scalars['String']>
  /** ID */
  id: Scalars['ID']
  /** Customizable metadata */
  metadata?: Maybe<Scalars['JSON']>
  /** Name */
  name?: Maybe<Scalars['String']>
  /** Cellphone */
  phone?: Maybe<Scalars['String']>
}

/** Autogenerated input type of ProfileUpdate */
export type ProfileUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** Email */
  email?: Maybe<Scalars['String']>
  /** Customizable metadata */
  metadata?: Maybe<Scalars['JSON']>
  /** Name */
  name?: Maybe<Scalars['String']>
  /** Cellphone in E164 Format */
  phone?: Maybe<Scalars['String']>
}

/** Autogenerated return type of ProfileUpdate */
export type ProfileUpdatePayload = {
  __typename?: 'ProfileUpdatePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** List of errors from mutation */
  errors?: Maybe<Array<Error>>
  /** Updated Profile Information */
  record?: Maybe<Profile>
  /** Status of the mutation */
  success: Scalars['Boolean']
}

/** The top-level Query type. Queries are used to fetch data. */
export type Query = {
  __typename?: 'Query'
  /** Look up an Account by its ID */
  account?: Maybe<Account>
  /** Get a list of a person's Accounts, sorted by type */
  accounts?: Maybe<Array<Account>>
  /** Look up a Bill by its ID */
  bill?: Maybe<Bill>
  /** Get a list of the user's Bills, sorted by next payment date */
  bills?: Maybe<Array<Bill>>
  /** Get list of Categories, sorted by name */
  categories: Array<Category>
  merchants?: Maybe<Array<Merchant>>
  /** Look up a Plaid Item by its ID */
  plaidItem?: Maybe<PlaidItem>
  /** Get a list of the user's Plaid Items */
  plaidItems?: Maybe<Array<PlaidItem>>
  /** Get profile information for the authenticated user */
  profile?: Maybe<Profile>
  recurrence?: Maybe<Recurrence>
  /** Look up a RoundUp by its ID */
  roundUp?: Maybe<RoundUp>
  /** Get a list of the user's RoundUps */
  roundUps?: Maybe<Array<RoundUp>>
  /** Look up a Transaction by its ID */
  transaction?: Maybe<Transaction>
  /** Get a cursor paginated list of the user's Transactions, sorted by descending date */
  transactionsConnection: TransactionConnection
}

/** The top-level Query type. Queries are used to fetch data. */
export type QueryAccountArgs = {
  id: Scalars['ID']
}

/** The top-level Query type. Queries are used to fetch data. */
export type QueryBillArgs = {
  id: Scalars['ID']
}

/** The top-level Query type. Queries are used to fetch data. */
export type QueryMerchantsArgs = {
  name?: Maybe<Scalars['String']>
}

/** The top-level Query type. Queries are used to fetch data. */
export type QueryPlaidItemArgs = {
  id: Scalars['ID']
}

/** The top-level Query type. Queries are used to fetch data. */
export type QueryRecurrenceArgs = {
  categoryId?: Maybe<Scalars['ID']>
  merchantId?: Maybe<Scalars['ID']>
  name?: Maybe<Scalars['String']>
}

/** The top-level Query type. Queries are used to fetch data. */
export type QueryRoundUpArgs = {
  id: Scalars['ID']
}

/** The top-level Query type. Queries are used to fetch data. */
export type QueryTransactionArgs = {
  id: Scalars['ID']
}

/** The top-level Query type. Queries are used to fetch data. */
export type QueryTransactionsConnectionArgs = {
  after?: Maybe<Scalars['String']>
  before?: Maybe<Scalars['String']>
  filter?: Maybe<TransactionFilter>
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
  sort?: Maybe<TransactionSort>
}

/** Represents a recurring set of Transactions */
export type Recurrence = {
  __typename?: 'Recurrence'
  /** Account from which this bill is usually paid */
  account?: Maybe<Account>
  /** Expected or nominal amount in absolute value */
  amount?: Maybe<Scalars['Float']>
  /** Category bill belongs to */
  category?: Maybe<Category>
  /** Frequency of occurrence */
  frequency?: Maybe<RecurrenceFrequency>
  /** Recurrence merchant */
  merchant?: Maybe<Merchant>
  /** Name */
  name?: Maybe<Scalars['String']>
}

/** Represents the frequency of a recurring event */
export enum RecurrenceFrequency {
  /** Every year */
  Annually = 'ANNUALLY',
  /** Every two weeks */
  Fortnightly = 'FORTNIGHTLY',
  /** Every month */
  Monthly = 'MONTHLY',
  /** Every three months */
  Quarterly = 'QUARTERLY',
  /** Every six months */
  Semiannually = 'SEMIANNUALLY',
  /** Twice per month */
  Semimonthly = 'SEMIMONTHLY',
  /** Unknown */
  Unknown = 'UNKNOWN',
  /** Every week */
  Weekly = 'WEEKLY',
}

/** Represents a RoundUp */
export type RoundUp = {
  __typename?: 'RoundUp'
  /** Eligible accounts available for this RoundUp */
  availableAccounts: Array<Account>
  /** Balance */
  balance: LedgerBalance
  /** Source or Funding account for this RoundUp */
  fundingAccount?: Maybe<Account>
  /** ID */
  id: Scalars['ID']
  /** Status */
  status: LedgerStatus
  /** Accounts subscribed to this RoundUp */
  subscribedAccounts: Array<Account>
  /** A limited list of transactions. Use `transactionsConnection` for a full paginated list. */
  transactions: Array<Transaction>
  /** Cursor-based pagination transactions */
  transactionsConnection: TransactionConnection
}

/** Represents a RoundUp */
export type RoundUpBalanceArgs = {
  filter?: Maybe<TransactionFilter>
}

/** Represents a RoundUp */
export type RoundUpTransactionsArgs = {
  filter?: Maybe<TransactionFilter>
  limit?: Scalars['Int']
  sort?: Maybe<TransactionSort>
}

/** Represents a RoundUp */
export type RoundUpTransactionsConnectionArgs = {
  after?: Maybe<Scalars['String']>
  before?: Maybe<Scalars['String']>
  filter?: Maybe<TransactionFilter>
  first?: Maybe<Scalars['Int']>
  last?: Maybe<Scalars['Int']>
  sort?: Maybe<TransactionSort>
}

/** Autogenerated input type of RoundUpCreate */
export type RoundUpCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** ID of the funding account */
  fundingAccountId?: Maybe<Scalars['ID']>
  /** IDs of subscribed accounts */
  subscribedAccountIds?: Maybe<Array<Scalars['ID']>>
}

/** Autogenerated return type of RoundUpCreate */
export type RoundUpCreatePayload = {
  __typename?: 'RoundUpCreatePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** List of errors from mutation */
  errors?: Maybe<Array<Error>>
  /** Created RoundUp */
  record?: Maybe<RoundUp>
  /** Status of the mutation */
  success: Scalars['Boolean']
}

/** Autogenerated input type of RoundUpPause */
export type RoundUpPauseInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** ID of the RoundUp */
  id: Scalars['ID']
}

/** Autogenerated return type of RoundUpPause */
export type RoundUpPausePayload = {
  __typename?: 'RoundUpPausePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** List of errors from mutation */
  errors?: Maybe<Array<Error>>
  /** Paused RoundUp */
  record?: Maybe<RoundUp>
  /** Status of the mutation */
  success: Scalars['Boolean']
}

/** Autogenerated input type of RoundUpResume */
export type RoundUpResumeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** ID of the RoundUp */
  id: Scalars['ID']
}

/** Autogenerated return type of RoundUpResume */
export type RoundUpResumePayload = {
  __typename?: 'RoundUpResumePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** List of errors from mutation */
  errors?: Maybe<Array<Error>>
  /** Resumed RoundUp */
  record?: Maybe<RoundUp>
  /** Status of the mutation */
  success: Scalars['Boolean']
}

/** Autogenerated input type of RoundUpSetFundingAccount */
export type RoundUpSetFundingAccountInput = {
  /** ID of the new funding account to use */
  accountId: Scalars['ID']
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** ID of the RoundUp */
  id: Scalars['ID']
}

/** Autogenerated return type of RoundUpSetFundingAccount */
export type RoundUpSetFundingAccountPayload = {
  __typename?: 'RoundUpSetFundingAccountPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** List of errors from mutation */
  errors?: Maybe<Array<Error>>
  /** Updated RoundUp */
  record?: Maybe<RoundUp>
  /** Status of the mutation */
  success: Scalars['Boolean']
}

/** Autogenerated input type of RoundUpSetStartTime */
export type RoundUpSetStartTimeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** ID of the RoundUp */
  id: Scalars['ID']
  /** Time to start rounding up at */
  startAt: Scalars['DateTime']
}

/** Autogenerated return type of RoundUpSetStartTime */
export type RoundUpSetStartTimePayload = {
  __typename?: 'RoundUpSetStartTimePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** List of errors from mutation */
  errors?: Maybe<Array<Error>>
  /** Updated RoundUp */
  record?: Maybe<RoundUp>
  /** Status of the mutation */
  success: Scalars['Boolean']
}

/** Autogenerated input type of RoundUpSubscribedAccountsAdd */
export type RoundUpSubscribedAccountsAddInput = {
  /** IDs of added Accounts */
  accountIds: Array<Scalars['ID']>
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** ID of the RoundUp */
  id: Scalars['ID']
}

/** Autogenerated return type of RoundUpSubscribedAccountsAdd */
export type RoundUpSubscribedAccountsAddPayload = {
  __typename?: 'RoundUpSubscribedAccountsAddPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** List of errors from mutation */
  errors?: Maybe<Array<Error>>
  /** Updated RoundUp */
  record?: Maybe<RoundUp>
  /** Status of the mutation */
  success: Scalars['Boolean']
}

/** Autogenerated input type of RoundUpSubscribedAccountsRemove */
export type RoundUpSubscribedAccountsRemoveInput = {
  /** IDs of removed Accounts */
  accountIds: Array<Scalars['ID']>
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** ID of the RoundUp */
  id: Scalars['ID']
}

/** Autogenerated return type of RoundUpSubscribedAccountsRemove */
export type RoundUpSubscribedAccountsRemovePayload = {
  __typename?: 'RoundUpSubscribedAccountsRemovePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** List of errors from mutation */
  errors?: Maybe<Array<Error>>
  /** Updated RoundUp */
  record?: Maybe<RoundUp>
  /** Status of the mutation */
  success: Scalars['Boolean']
}

export type SourceAccounts = PlaidAccount

export type SourceTransactions = PlaidTransaction

/** Represents the source of the data */
export enum SourceTypes {
  /** Plaid connection */
  Plaid = 'PLAID',
  /** QRails connection */
  Qrails = 'QRAILS',
}

/** The top-level Subscription type. Subscriptions are used to watch for events emitted from the server. */
export type Subscription = {
  __typename?: 'Subscription'
  /** A plaid item was updated */
  plaidItemUpdated: PlaidItemUpdatedPayload
}

/** The top-level Subscription type. Subscriptions are used to watch for events emitted from the server. */
export type SubscriptionPlaidItemUpdatedArgs = {
  id: Scalars['ID']
}

/** Represents a Transaction */
export type Transaction = {
  __typename?: 'Transaction'
  /** Transaction account */
  account: Account
  /** Amount */
  amount: Scalars['Float']
  /** Date of Record */
  date: Scalars['Date']
  /** Description or Line Item Name */
  description: Scalars['String']
  /** CREDIT or DEBIT */
  entryType: TransactionEntryTypes
  /** ID */
  id: Scalars['ID']
  /** Customizable metadata */
  metadata?: Maybe<Scalars['JSON']>
  /** API Data Source */
  source?: Maybe<SourceTransactions>
  /** API Data Sources */
  sources?: Maybe<Array<SourceTransactions>>
  /** Status */
  status: TransactionStatus
}

/** Represents a Transaction */
export type TransactionSourceArgs = {
  type: SourceTypes
}

/** Represents a Transaction */
export type TransactionSourcesArgs = {
  types?: Maybe<Array<SourceTypes>>
}

/** The connection type for Transaction. */
export type TransactionConnection = {
  __typename?: 'TransactionConnection'
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<TransactionEdge>>>
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Transaction>>>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
}

/** An edge in a connection. */
export type TransactionEdge = {
  __typename?: 'TransactionEdge'
  /** A cursor for use in pagination. */
  cursor: Scalars['String']
  /** The item at the end of the edge. */
  node?: Maybe<Transaction>
}

/** Whether the Transaction is a CREDIT or DEBIT */
export enum TransactionEntryTypes {
  /** an entry recording money being advanced into the account */
  Credit = 'CREDIT',
  /** an entry recording money being withdrawn from the account */
  Debit = 'DEBIT',
}

/** Options for Filtering Transactions */
export type TransactionFilter = {
  /** Amount */
  amount?: Maybe<Scalars['Float']>
  /** Amount greater than */
  amount_gt?: Maybe<Scalars['Float']>
  /** Amount greater than or equal to */
  amount_gte?: Maybe<Scalars['Float']>
  /** Amount less than */
  amount_lt?: Maybe<Scalars['Float']>
  /** Amount less than or equal to */
  amount_lte?: Maybe<Scalars['Float']>
  /** Date */
  date?: Maybe<Scalars['Date']>
  /** Date greater than */
  date_gt?: Maybe<Scalars['Date']>
  /** Date greater than or equal to */
  date_gte?: Maybe<Scalars['Date']>
  /** Date less than */
  date_lt?: Maybe<Scalars['Date']>
  /** Date less than or equal to */
  date_lte?: Maybe<Scalars['Date']>
}

/** Options for Sorting Transactions */
export enum TransactionSort {
  /** Oldest First, Pending Last */
  DateAsc = 'DATE_ASC',
  /** Newest First, Pending First */
  DateDesc = 'DATE_DESC',
}

/** Represents the pending, posted, or projected status for a transaction */
export enum TransactionStatus {
  /** Awaiting decision or settlement, may be replaced, updated, or removed */
  Pending = 'PENDING',
  /** Announced or published as conclusive */
  Posted = 'POSTED',
  /** Estimated or forecast on the basis of current trends or data */
  Projected = 'PROJECTED',
}

/** Autogenerated input type of TransactionUpdate */
export type TransactionUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  id: Scalars['ID']
  /** Customizable metadata */
  metadata?: Maybe<Scalars['JSON']>
}

/** Autogenerated return type of TransactionUpdate */
export type TransactionUpdatePayload = {
  __typename?: 'TransactionUpdatePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>
  /** List of errors from mutation */
  errors?: Maybe<Array<Error>>
  /** Updated Account Information */
  record?: Maybe<Account>
  /** Status of the mutation */
  success: Scalars['Boolean']
}

export type MerchantsQueryVariables = Exact<{
  name: Scalars['String']
}>

export type MerchantsQuery = { __typename?: 'Query' } & {
  merchants?: Maybe<
    Array<{ __typename?: 'Merchant' } & Pick<Merchant, 'name' | 'id'>>
  >
}

export type CategoriesQueryVariables = Exact<{ [key: string]: never }>

export type CategoriesQuery = { __typename?: 'Query' } & {
  categories: Array<
    { __typename?: 'Category' } & Pick<
      Category,
      'id' | 'name' | 'description' | 'emojiName' | 'emoji'
    >
  >
}

export type BillsQueryVariables = Exact<{ [key: string]: never }>

export type BillsQuery = { __typename?: 'Query' } & {
  bills?: Maybe<Array<{ __typename?: 'Bill' } & BillFragmentFragment>>
}

export type BillDetailQueryVariables = Exact<{
  id: Scalars['ID']
}>

export type BillDetailQuery = { __typename?: 'Query' } & {
  bill?: Maybe<
    { __typename?: 'Bill' } & {
      account?: Maybe<{ __typename?: 'Account' } & Pick<Account, 'id' | 'name'>>
      transactions: Array<
        { __typename?: 'Transaction' } & Pick<
          Transaction,
          'id' | 'amount' | 'date'
        >
      >
    } & BillFragmentFragment
  >
}

export type BillTemplateQueryVariables = Exact<{
  categoryId?: Maybe<Scalars['ID']>
  merchantId?: Maybe<Scalars['ID']>
  name?: Maybe<Scalars['String']>
}>

export type BillTemplateQuery = { __typename?: 'Query' } & {
  recurrence?: Maybe<
    { __typename?: 'Recurrence' } & Pick<
      Recurrence,
      'name' | 'frequency' | 'amount'
    > & {
        merchant?: Maybe<{ __typename?: 'Merchant' } & Pick<Merchant, 'id'>>
        category?: Maybe<{ __typename?: 'Category' } & Pick<Category, 'id'>>
      }
  >
}

export type CreateBillMutationVariables = Exact<{
  input: BillCreateInput
}>

export type CreateBillMutation = { __typename?: 'Mutation' } & {
  billCreate?: Maybe<
    { __typename?: 'BillCreatePayload' } & {
      record?: Maybe<{ __typename?: 'Bill' } & BillFragmentFragment>
      errors?: Maybe<
        Array<{ __typename?: 'Error' } & Pick<Error, 'message' | 'path'>>
      >
    }
  >
}

export type UpdateBillMutationVariables = Exact<{
  input: BillUpdateInput
}>

export type UpdateBillMutation = { __typename?: 'Mutation' } & {
  billUpdate?: Maybe<
    { __typename?: 'BillUpdatePayload' } & {
      record?: Maybe<{ __typename?: 'Bill' } & BillFragmentFragment>
      errors?: Maybe<
        Array<{ __typename?: 'Error' } & Pick<Error, 'message' | 'path'>>
      >
    }
  >
}

export type NextPaycheckQueryQueryVariables = Exact<{ [key: string]: never }>

export type NextPaycheckQueryQuery = { __typename?: 'Query' } & {
  profile?: Maybe<{ __typename?: 'Profile' } & Pick<Profile, 'name'>>
}

export type RoundUpActivateMutationVariables = Exact<{
  id: Scalars['ID']
  startAt: Scalars['DateTime']
  startOn?: Maybe<Scalars['Date']>
}>

export type RoundUpActivateMutation = { __typename?: 'Mutation' } & {
  roundUpSetStartTime?: Maybe<
    { __typename?: 'RoundUpSetStartTimePayload' } & Pick<
      RoundUpSetStartTimePayload,
      'success'
    > & {
        record?: Maybe<
          { __typename?: 'RoundUp' } & Pick<RoundUp, 'id'> & {
              balance: { __typename?: 'LedgerBalance' } & Pick<
                LedgerBalance,
                'id' | 'available'
              >
              transactionsConnection: {
                __typename?: 'TransactionConnection'
              } & {
                nodes?: Maybe<
                  Array<
                    Maybe<
                      { __typename?: 'Transaction' } & Pick<
                        Transaction,
                        'id' | 'date' | 'amount' | 'description'
                      >
                    >
                  >
                >
              }
            }
        >
      }
  >
}

export type RoundUpActivateDateSearchQueryVariables = Exact<{
  id: Scalars['ID']
}>

export type RoundUpActivateDateSearchQuery = { __typename?: 'Query' } & {
  roundUp?: Maybe<
    { __typename?: 'RoundUp' } & Pick<RoundUp, 'id'> & {
        subscribedAccounts: Array<
          { __typename?: 'Account' } & Pick<Account, 'id'> & {
              transactions: Array<
                { __typename?: 'Transaction' } & Pick<
                  Transaction,
                  'id' | 'date' | 'amount' | 'status'
                >
              >
            }
        >
      }
  >
}

export type RoundUpsBankConnectionsAccountsListQueryVariables = Exact<{
  roundUpId: Scalars['ID']
  bankConnectionId: Scalars['ID']
}>

export type RoundUpsBankConnectionsAccountsListQuery = {
  __typename?: 'Query'
} & {
  roundUp?: Maybe<
    { __typename?: 'RoundUp' } & Pick<RoundUp, 'id'> & {
        fundingAccount?: Maybe<{ __typename?: 'Account' } & Pick<Account, 'id'>>
      }
  >
  plaidItem?: Maybe<
    { __typename?: 'PlaidItem' } & Pick<
      PlaidItem,
      'id' | 'name' | 'status' | 'syncedAt'
    > & {
        logo?: Maybe<{ __typename?: 'Image' } & Pick<Image, 'url'>>
        accounts: Array<
          { __typename?: 'Account' } & Pick<Account, 'id' | 'name'>
        >
      }
  >
}

export type RoundUpsBankConnectionsAccountsListItemQueryVariables = Exact<{
  roundUpId: Scalars['ID']
  accountId: Scalars['ID']
}>

export type RoundUpsBankConnectionsAccountsListItemQuery = {
  __typename?: 'Query'
} & {
  roundUp?: Maybe<
    { __typename?: 'RoundUp' } & Pick<RoundUp, 'id'> & {
        fundingAccount?: Maybe<{ __typename?: 'Account' } & Pick<Account, 'id'>>
        subscribedAccounts: Array<
          { __typename?: 'Account' } & Pick<Account, 'id'>
        >
        availableAccounts: Array<
          { __typename?: 'Account' } & Pick<Account, 'id'>
        >
      }
  >
  account?: Maybe<
    { __typename?: 'Account' } & Pick<Account, 'id' | 'name' | 'lastFourDigits'>
  >
}

export type RoundUpsAccountsSubscribeMutationVariables = Exact<{
  id: Scalars['ID']
  accountId: Scalars['ID']
}>

export type RoundUpsAccountsSubscribeMutation = { __typename?: 'Mutation' } & {
  roundUpSubscribedAccountsAdd?: Maybe<
    { __typename?: 'RoundUpSubscribedAccountsAddPayload' } & {
      record?: Maybe<
        { __typename?: 'RoundUp' } & Pick<RoundUp, 'id'> & {
            subscribedAccounts: Array<
              { __typename?: 'Account' } & Pick<Account, 'id'>
            >
            availableAccounts: Array<
              { __typename?: 'Account' } & Pick<Account, 'id'>
            >
          }
      >
    }
  >
}

export type RoundUpsAccountsUnsubscribeMutationVariables = Exact<{
  id: Scalars['ID']
  accountId: Scalars['ID']
}>

export type RoundUpsAccountsUnsubscribeMutation = {
  __typename?: 'Mutation'
} & {
  roundUpSubscribedAccountsRemove?: Maybe<
    { __typename?: 'RoundUpSubscribedAccountsRemovePayload' } & {
      record?: Maybe<
        { __typename?: 'RoundUp' } & Pick<RoundUp, 'id'> & {
            subscribedAccounts: Array<
              { __typename?: 'Account' } & Pick<Account, 'id'>
            >
            availableAccounts: Array<
              { __typename?: 'Account' } & Pick<Account, 'id'>
            >
          }
      >
    }
  >
}

export type RoundUpsBankConnectionsAddFundingMutationVariables = Exact<{
  roundUpId: Scalars['ID']
  publicToken: Scalars['String']
  metadata: Scalars['JSON']
  accountId: Scalars['ID']
}>

export type RoundUpsBankConnectionsAddFundingMutation = {
  __typename?: 'Mutation'
} & {
  plaidItemCreate?: Maybe<
    { __typename?: 'PlaidItemCreatePayload' } & Pick<
      PlaidItemCreatePayload,
      'success'
    > & { record?: Maybe<{ __typename?: 'PlaidItem' } & Pick<PlaidItem, 'id'>> }
  >
  roundUpSetFundingAccount?: Maybe<
    { __typename?: 'RoundUpSetFundingAccountPayload' } & Pick<
      RoundUpSetFundingAccountPayload,
      'success'
    > & { record?: Maybe<{ __typename?: 'RoundUp' } & Pick<RoundUp, 'id'>> }
  >
  roundUpSubscribedAccountsAdd?: Maybe<
    { __typename?: 'RoundUpSubscribedAccountsAddPayload' } & Pick<
      RoundUpSubscribedAccountsAddPayload,
      'success'
    > & { record?: Maybe<{ __typename?: 'RoundUp' } & Pick<RoundUp, 'id'>> }
  >
}

export type RoundUpsBankConnectionsAddSubscriptionMutationVariables = Exact<{
  roundUpId: Scalars['ID']
  publicToken: Scalars['String']
  metadata: Scalars['JSON']
  accountIds: Array<Scalars['ID']>
}>

export type RoundUpsBankConnectionsAddSubscriptionMutation = {
  __typename?: 'Mutation'
} & {
  plaidItemCreate?: Maybe<
    { __typename?: 'PlaidItemCreatePayload' } & Pick<
      PlaidItemCreatePayload,
      'success'
    > & {
        record?: Maybe<{ __typename?: 'PlaidItem' } & PlaidItemFragmentFragment>
      }
  >
  roundUpSubscribedAccountsAdd?: Maybe<
    { __typename?: 'RoundUpSubscribedAccountsAddPayload' } & Pick<
      RoundUpSubscribedAccountsAddPayload,
      'success'
    > & { record?: Maybe<{ __typename?: 'RoundUp' } & Pick<RoundUp, 'id'>> }
  >
}

export type RoundUpsRecentActivityQueryVariables = Exact<{
  roundUpId: Scalars['ID']
  since: Scalars['Date']
}>

export type RoundUpsRecentActivityQuery = { __typename?: 'Query' } & {
  roundUp?: Maybe<
    { __typename?: 'RoundUp' } & Pick<RoundUp, 'id'> & {
        recentActivity: { __typename?: 'LedgerBalance' } & Pick<
          LedgerBalance,
          'id' | 'current'
        >
      }
  >
}

export type RoundUpsBankConnectionsSummaryCardFooterQueryVariables = Exact<{
  id: Scalars['ID']
}>

export type RoundUpsBankConnectionsSummaryCardFooterQuery = {
  __typename?: 'Query'
} & {
  roundUp?: Maybe<
    { __typename?: 'RoundUp' } & Pick<RoundUp, 'id'> & {
        fundingAccount?: Maybe<{ __typename?: 'Account' } & Pick<Account, 'id'>>
      }
  >
}

export type RoundUpsBankConnectionsSummaryCardHeaderQueryVariables = Exact<{
  [key: string]: never
}>

export type RoundUpsBankConnectionsSummaryCardHeaderQuery = {
  __typename?: 'Query'
} & {
  plaidItems?: Maybe<
    Array<{ __typename?: 'PlaidItem' } & Pick<PlaidItem, 'id'>>
  >
}

export type RoundUpsBankConnectionsCardQueryVariables = Exact<{
  roundUpId: Scalars['ID']
  id: Scalars['ID']
}>

export type RoundUpsBankConnectionsCardQuery = { __typename?: 'Query' } & {
  roundUp?: Maybe<{ __typename?: 'RoundUp' } & Pick<RoundUp, 'id'>>
  plaidItem?: Maybe<
    { __typename?: 'PlaidItem' } & Pick<PlaidItem, 'id' | 'name'> & {
        logo?: Maybe<{ __typename?: 'Image' } & Pick<Image, 'url'>>
      }
  >
}

export type RoundUpsBankConnectionsListQueryVariables = Exact<{
  roundUpId: Scalars['ID']
}>

export type RoundUpsBankConnectionsListQuery = { __typename?: 'Query' } & {
  roundUp?: Maybe<
    { __typename?: 'RoundUp' } & Pick<RoundUp, 'id'> & {
        fundingAccount?: Maybe<
          { __typename?: 'Account' } & AccountFragmentFragment
        >
      }
  >
  plaidItems?: Maybe<
    Array<
      { __typename?: 'PlaidItem' } & Pick<
        PlaidItem,
        'id' | 'name' | 'status' | 'syncedAt'
      > & { logo?: Maybe<{ __typename?: 'Image' } & Pick<Image, 'url'>> }
    >
  >
}

export type RoundUpsBankConnectionsListItemQueryVariables = Exact<{
  roundUpId: Scalars['ID']
  id: Scalars['ID']
}>

export type RoundUpsBankConnectionsListItemQuery = { __typename?: 'Query' } & {
  roundUp?: Maybe<
    { __typename?: 'RoundUp' } & Pick<RoundUp, 'id'> & {
        fundingAccount?: Maybe<
          { __typename?: 'Account' } & AccountFragmentFragment
        >
      }
  >
  plaidItem?: Maybe<
    { __typename?: 'PlaidItem' } & Pick<
      PlaidItem,
      'id' | 'name' | 'status' | 'syncedAt'
    > & { logo?: Maybe<{ __typename?: 'Image' } & Pick<Image, 'url'>> }
  >
}

export type RoundUpsBankConnectionsPageQueryVariables = Exact<{
  id: Scalars['ID']
}>

export type RoundUpsBankConnectionsPageQuery = { __typename?: 'Query' } & {
  roundUp?: Maybe<
    { __typename?: 'RoundUp' } & Pick<RoundUp, 'id'> & {
        fundingAccount?: Maybe<{ __typename?: 'Account' } & Pick<Account, 'id'>>
      }
  >
  plaidItems?: Maybe<
    Array<
      { __typename?: 'PlaidItem' } & Pick<PlaidItem, 'id'> & {
          accounts: Array<{ __typename?: 'Account' } & Pick<Account, 'id'>>
        }
    >
  >
}

export type RoundUpsPauseMutationVariables = Exact<{
  id: Scalars['ID']
}>

export type RoundUpsPauseMutation = { __typename?: 'Mutation' } & {
  roundUpPause?: Maybe<
    { __typename?: 'RoundUpPausePayload' } & {
      record?: Maybe<
        { __typename?: 'RoundUp' } & Pick<RoundUp, 'id' | 'status'>
      >
    }
  >
}

export type RoundUpsResumeMutationVariables = Exact<{
  id: Scalars['ID']
}>

export type RoundUpsResumeMutation = { __typename?: 'Mutation' } & {
  roundUpResume?: Maybe<
    { __typename?: 'RoundUpResumePayload' } & {
      record?: Maybe<
        { __typename?: 'RoundUp' } & Pick<RoundUp, 'id' | 'status'>
      >
    }
  >
}

export type RoundUpSummaryQueryVariables = Exact<{
  id: Scalars['ID']
  startOfWeek?: Maybe<Scalars['Date']>
}>

export type RoundUpSummaryQuery = { __typename?: 'Query' } & {
  roundUp?: Maybe<
    { __typename?: 'RoundUp' } & Pick<RoundUp, 'id'> & {
        totalAmount: { __typename?: 'LedgerBalance' } & Pick<
          LedgerBalance,
          'id' | 'available' | 'current'
        >
        thisWeek: { __typename?: 'LedgerBalance' } & Pick<
          LedgerBalance,
          'id' | 'available' | 'current'
        >
      }
  >
}

export type RoundUpHistoryQueryVariables = Exact<{
  id: Scalars['ID']
  day0: Scalars['Date']
  day1: Scalars['Date']
  day2: Scalars['Date']
  day3: Scalars['Date']
  day4: Scalars['Date']
  day5: Scalars['Date']
  day6: Scalars['Date']
}>

export type RoundUpHistoryQuery = { __typename?: 'Query' } & {
  roundUp?: Maybe<
    { __typename?: 'RoundUp' } & Pick<RoundUp, 'id'> & {
        day0: { __typename?: 'LedgerBalance' } & Pick<
          LedgerBalance,
          'id' | 'available'
        >
        day1: { __typename?: 'LedgerBalance' } & Pick<
          LedgerBalance,
          'id' | 'available'
        >
        day2: { __typename?: 'LedgerBalance' } & Pick<
          LedgerBalance,
          'id' | 'available'
        >
        day3: { __typename?: 'LedgerBalance' } & Pick<
          LedgerBalance,
          'id' | 'available'
        >
        day4: { __typename?: 'LedgerBalance' } & Pick<
          LedgerBalance,
          'id' | 'available'
        >
        day5: { __typename?: 'LedgerBalance' } & Pick<
          LedgerBalance,
          'id' | 'available'
        >
        day6: { __typename?: 'LedgerBalance' } & Pick<
          LedgerBalance,
          'id' | 'available'
        >
      }
  >
}

export type RoundUpTransactionsQueryVariables = Exact<{
  id: Scalars['ID']
}>

export type RoundUpTransactionsQuery = { __typename?: 'Query' } & {
  roundUp?: Maybe<
    { __typename?: 'RoundUp' } & Pick<RoundUp, 'id'> & {
        transactionsConnection: { __typename?: 'TransactionConnection' } & {
          edges?: Maybe<
            Array<
              Maybe<
                { __typename?: 'TransactionEdge' } & {
                  node?: Maybe<
                    { __typename?: 'Transaction' } & Pick<
                      Transaction,
                      'id' | 'date' | 'amount' | 'description'
                    >
                  >
                }
              >
            >
          >
        }
      }
  >
}

export type RoundUpsQueryVariables = Exact<{ [key: string]: never }>

export type RoundUpsQuery = { __typename?: 'Query' } & {
  roundUps?: Maybe<Array<{ __typename?: 'RoundUp' } & Pick<RoundUp, 'id'>>>
}

export type RoundUpHomeQueryVariables = Exact<{
  id: Scalars['ID']
}>

export type RoundUpHomeQuery = { __typename?: 'Query' } & {
  roundUp?: Maybe<
    { __typename?: 'RoundUp' } & Pick<RoundUp, 'id' | 'status'> & {
        fundingAccount?: Maybe<{ __typename?: 'Account' } & Pick<Account, 'id'>>
      }
  >
}

export type CreateRoundUpMutationVariables = Exact<{ [key: string]: never }>

export type CreateRoundUpMutation = { __typename?: 'Mutation' } & {
  roundUpCreate?: Maybe<
    { __typename?: 'RoundUpCreatePayload' } & Pick<
      RoundUpCreatePayload,
      'success'
    > & {
        record?: Maybe<
          { __typename?: 'RoundUp' } & Pick<RoundUp, 'id' | 'status'>
        >
      }
  >
}

export type PlaidItemsQueryVariables = Exact<{ [key: string]: never }>

export type PlaidItemsQuery = { __typename?: 'Query' } & {
  plaidItems?: Maybe<
    Array<{ __typename?: 'PlaidItem' } & PlaidItemFragmentFragment>
  >
}

export type PlaidItemSyncStatusQueryVariables = Exact<{
  id: Scalars['ID']
}>

export type PlaidItemSyncStatusQuery = { __typename?: 'Query' } & {
  plaidItem?: Maybe<
    { __typename?: 'PlaidItem' } & Pick<PlaidItem, 'id' | 'status' | 'syncedAt'>
  >
}

export type PlaidLinkTokenCreateMutationVariables = Exact<{
  input: PlaidLinkTokenCreateInput
}>

export type PlaidLinkTokenCreateMutation = { __typename?: 'Mutation' } & {
  plaidLinkTokenCreate?: Maybe<
    { __typename?: 'PlaidLinkTokenCreatePayload' } & {
      record?: Maybe<
        { __typename?: 'PlaidLinkToken' } & Pick<
          PlaidLinkToken,
          'linkToken' | 'expiration'
        >
      >
      errors?: Maybe<
        Array<
          { __typename?: 'PlaidAPIError' } & Pick<
            PlaidApiError,
            'code' | 'type' | 'message' | 'requestId' | 'displayMessage'
          >
        >
      >
    }
  >
}

export type PlaidLinkTokenCreateForUpdateMutationVariables = Exact<{
  input: PlaidLinkTokenCreateForUpdateInput
}>

export type PlaidLinkTokenCreateForUpdateMutation = {
  __typename?: 'Mutation'
} & {
  plaidLinkTokenCreateForUpdate?: Maybe<
    { __typename?: 'PlaidLinkTokenCreateForUpdatePayload' } & {
      record?: Maybe<
        { __typename?: 'PlaidLinkToken' } & Pick<
          PlaidLinkToken,
          'linkToken' | 'expiration'
        >
      >
      errors?: Maybe<
        Array<
          { __typename?: 'PlaidAPIError' } & Pick<
            PlaidApiError,
            'code' | 'type' | 'message' | 'requestId' | 'displayMessage'
          >
        >
      >
    }
  >
}

export type PlaidItemCreateMutationVariables = Exact<{
  input: PlaidItemCreateInput
}>

export type PlaidItemCreateMutation = { __typename?: 'Mutation' } & {
  plaidItemCreate?: Maybe<
    { __typename?: 'PlaidItemCreatePayload' } & {
      record?: Maybe<{ __typename?: 'PlaidItem' } & PlaidItemFragmentFragment>
      errors?: Maybe<
        Array<
          { __typename?: 'PlaidAPIError' } & Pick<
            PlaidApiError,
            'displayMessage'
          >
        >
      >
    }
  >
}

export type PlaidItemUnlinkMutationVariables = Exact<{
  id: Scalars['ID']
}>

export type PlaidItemUnlinkMutation = { __typename?: 'Mutation' } & {
  plaidItemDelete?: Maybe<
    { __typename?: 'PlaidItemDeletePayload' } & Pick<
      PlaidItemDeletePayload,
      'success'
    > & { record?: Maybe<{ __typename?: 'PlaidItem' } & Pick<PlaidItem, 'id'>> }
  >
}

export type PlaidItemUpdatedSubscriptionVariables = Exact<{
  id: Scalars['ID']
}>

export type PlaidItemUpdatedSubscription = { __typename?: 'Subscription' } & {
  plaidItemUpdated: { __typename?: 'PlaidItemUpdatedPayload' } & {
    record?: Maybe<{ __typename?: 'PlaidItem' } & PlaidItemFragmentFragment>
  }
}

export type ProfileFragmentFragment = { __typename?: 'Profile' } & Pick<
  Profile,
  'name' | 'email' | 'phone'
>

export type ProfileQueryVariables = Exact<{ [key: string]: never }>

export type ProfileQuery = { __typename?: 'Query' } & {
  profile?: Maybe<{ __typename?: 'Profile' } & ProfileFragmentFragment>
}

export type ProfileUpdateMutationVariables = Exact<{
  input: ProfileUpdateInput
}>

export type ProfileUpdateMutation = { __typename?: 'Mutation' } & {
  profileUpdate?: Maybe<
    { __typename?: 'ProfileUpdatePayload' } & {
      record?: Maybe<{ __typename?: 'Profile' } & ProfileFragmentFragment>
      errors?: Maybe<
        Array<{ __typename?: 'Error' } & Pick<Error, 'path' | 'message'>>
      >
    }
  >
}

export type AccountFragmentFragment = { __typename?: 'Account' } & Pick<
  Account,
  'id' | 'lastFourDigits' | 'name' | 'type'
> & { plaidItem?: Maybe<{ __typename?: 'PlaidItem' } & Pick<PlaidItem, 'id'>> }

export type BillFragmentFragment = { __typename?: 'Bill' } & Pick<
  Bill,
  'id' | 'name' | 'amount' | 'frequency' | 'nextPaymentDate' | 'status'
> & {
    category?: Maybe<
      { __typename?: 'Category' } & Pick<Category, 'name' | 'id' | 'emoji'>
    >
  }

export type PlaidItemFragmentFragment = { __typename?: 'PlaidItem' } & Pick<
  PlaidItem,
  'id' | 'name' | 'status' | 'syncedAt'
> & {
    logo?: Maybe<{ __typename?: 'Image' } & Pick<Image, 'url'>>
    accounts: Array<
      { __typename?: 'Account' } & Pick<
        Account,
        'id' | 'name' | 'lastFourDigits' | 'type'
      > & {
          balance: { __typename?: 'LedgerBalance' } & Pick<
            LedgerBalance,
            'current'
          >
        }
    >
  }

export const ProfileFragmentFragmentDoc = gql`
  fragment ProfileFragment on Profile {
    name
    email
    phone
  }
`
export const AccountFragmentFragmentDoc = gql`
  fragment AccountFragment on Account {
    id
    lastFourDigits
    name
    type
    plaidItem {
      id
    }
  }
`
export const BillFragmentFragmentDoc = gql`
  fragment BillFragment on Bill {
    id
    name
    amount
    frequency
    nextPaymentDate
    status
    category {
      name
      id
      emoji
    }
  }
`
export const PlaidItemFragmentFragmentDoc = gql`
  fragment PlaidItemFragment on PlaidItem {
    id
    name
    logo {
      url
    }
    status
    syncedAt
    accounts {
      id
      name
      balance {
        current
      }
      lastFourDigits
      type
    }
  }
`
export const MerchantsDocument = gql`
  query Merchants($name: String!) {
    merchants(name: $name) {
      name
      id
    }
  }
`

/**
 * __useMerchantsQuery__
 *
 * To run a query within a React component, call `useMerchantsQuery` and pass it any options that fit your needs.
 * When your component renders, `useMerchantsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMerchantsQuery({
 *   variables: {
 *      name: // value for 'name'
 *   },
 * });
 */
export function useMerchantsQuery(
  baseOptions: Apollo.QueryHookOptions<MerchantsQuery, MerchantsQueryVariables>
) {
  return Apollo.useQuery<MerchantsQuery, MerchantsQueryVariables>(
    MerchantsDocument,
    baseOptions
  )
}
export function useMerchantsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    MerchantsQuery,
    MerchantsQueryVariables
  >
) {
  return Apollo.useLazyQuery<MerchantsQuery, MerchantsQueryVariables>(
    MerchantsDocument,
    baseOptions
  )
}
export type MerchantsQueryHookResult = ReturnType<typeof useMerchantsQuery>
export type MerchantsLazyQueryHookResult = ReturnType<
  typeof useMerchantsLazyQuery
>
export type MerchantsQueryResult = Apollo.QueryResult<
  MerchantsQuery,
  MerchantsQueryVariables
>
export const CategoriesDocument = gql`
  query Categories {
    categories {
      id
      name
      description
      emojiName
      emoji
    }
  }
`

/**
 * __useCategoriesQuery__
 *
 * To run a query within a React component, call `useCategoriesQuery` and pass it any options that fit your needs.
 * When your component renders, `useCategoriesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCategoriesQuery({
 *   variables: {
 *   },
 * });
 */
export function useCategoriesQuery(
  baseOptions?: Apollo.QueryHookOptions<
    CategoriesQuery,
    CategoriesQueryVariables
  >
) {
  return Apollo.useQuery<CategoriesQuery, CategoriesQueryVariables>(
    CategoriesDocument,
    baseOptions
  )
}
export function useCategoriesLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    CategoriesQuery,
    CategoriesQueryVariables
  >
) {
  return Apollo.useLazyQuery<CategoriesQuery, CategoriesQueryVariables>(
    CategoriesDocument,
    baseOptions
  )
}
export type CategoriesQueryHookResult = ReturnType<typeof useCategoriesQuery>
export type CategoriesLazyQueryHookResult = ReturnType<
  typeof useCategoriesLazyQuery
>
export type CategoriesQueryResult = Apollo.QueryResult<
  CategoriesQuery,
  CategoriesQueryVariables
>
export const BillsDocument = gql`
  query Bills {
    bills {
      ...BillFragment
    }
  }
  ${BillFragmentFragmentDoc}
`

/**
 * __useBillsQuery__
 *
 * To run a query within a React component, call `useBillsQuery` and pass it any options that fit your needs.
 * When your component renders, `useBillsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useBillsQuery({
 *   variables: {
 *   },
 * });
 */
export function useBillsQuery(
  baseOptions?: Apollo.QueryHookOptions<BillsQuery, BillsQueryVariables>
) {
  return Apollo.useQuery<BillsQuery, BillsQueryVariables>(
    BillsDocument,
    baseOptions
  )
}
export function useBillsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<BillsQuery, BillsQueryVariables>
) {
  return Apollo.useLazyQuery<BillsQuery, BillsQueryVariables>(
    BillsDocument,
    baseOptions
  )
}
export type BillsQueryHookResult = ReturnType<typeof useBillsQuery>
export type BillsLazyQueryHookResult = ReturnType<typeof useBillsLazyQuery>
export type BillsQueryResult = Apollo.QueryResult<
  BillsQuery,
  BillsQueryVariables
>
export const BillDetailDocument = gql`
  query BillDetail($id: ID!) {
    bill(id: $id) {
      ...BillFragment
      account {
        id
        name
      }
      transactions {
        id
        amount
        date
      }
    }
  }
  ${BillFragmentFragmentDoc}
`

/**
 * __useBillDetailQuery__
 *
 * To run a query within a React component, call `useBillDetailQuery` and pass it any options that fit your needs.
 * When your component renders, `useBillDetailQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useBillDetailQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useBillDetailQuery(
  baseOptions: Apollo.QueryHookOptions<
    BillDetailQuery,
    BillDetailQueryVariables
  >
) {
  return Apollo.useQuery<BillDetailQuery, BillDetailQueryVariables>(
    BillDetailDocument,
    baseOptions
  )
}
export function useBillDetailLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    BillDetailQuery,
    BillDetailQueryVariables
  >
) {
  return Apollo.useLazyQuery<BillDetailQuery, BillDetailQueryVariables>(
    BillDetailDocument,
    baseOptions
  )
}
export type BillDetailQueryHookResult = ReturnType<typeof useBillDetailQuery>
export type BillDetailLazyQueryHookResult = ReturnType<
  typeof useBillDetailLazyQuery
>
export type BillDetailQueryResult = Apollo.QueryResult<
  BillDetailQuery,
  BillDetailQueryVariables
>
export const BillTemplateDocument = gql`
  query BillTemplate($categoryId: ID, $merchantId: ID, $name: String) {
    recurrence(categoryId: $categoryId, merchantId: $merchantId, name: $name) {
      name
      frequency
      amount
      merchant {
        id
      }
      category {
        id
      }
    }
  }
`

/**
 * __useBillTemplateQuery__
 *
 * To run a query within a React component, call `useBillTemplateQuery` and pass it any options that fit your needs.
 * When your component renders, `useBillTemplateQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useBillTemplateQuery({
 *   variables: {
 *      categoryId: // value for 'categoryId'
 *      merchantId: // value for 'merchantId'
 *      name: // value for 'name'
 *   },
 * });
 */
export function useBillTemplateQuery(
  baseOptions?: Apollo.QueryHookOptions<
    BillTemplateQuery,
    BillTemplateQueryVariables
  >
) {
  return Apollo.useQuery<BillTemplateQuery, BillTemplateQueryVariables>(
    BillTemplateDocument,
    baseOptions
  )
}
export function useBillTemplateLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    BillTemplateQuery,
    BillTemplateQueryVariables
  >
) {
  return Apollo.useLazyQuery<BillTemplateQuery, BillTemplateQueryVariables>(
    BillTemplateDocument,
    baseOptions
  )
}
export type BillTemplateQueryHookResult = ReturnType<
  typeof useBillTemplateQuery
>
export type BillTemplateLazyQueryHookResult = ReturnType<
  typeof useBillTemplateLazyQuery
>
export type BillTemplateQueryResult = Apollo.QueryResult<
  BillTemplateQuery,
  BillTemplateQueryVariables
>
export const CreateBillDocument = gql`
  mutation CreateBill($input: BillCreateInput!) {
    billCreate(input: $input) {
      record {
        ...BillFragment
      }
      errors {
        message
        path
      }
    }
  }
  ${BillFragmentFragmentDoc}
`
export type CreateBillMutationFn = Apollo.MutationFunction<
  CreateBillMutation,
  CreateBillMutationVariables
>

/**
 * __useCreateBillMutation__
 *
 * To run a mutation, you first call `useCreateBillMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateBillMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createBillMutation, { data, loading, error }] = useCreateBillMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateBillMutation(
  baseOptions?: Apollo.MutationHookOptions<
    CreateBillMutation,
    CreateBillMutationVariables
  >
) {
  return Apollo.useMutation<CreateBillMutation, CreateBillMutationVariables>(
    CreateBillDocument,
    baseOptions
  )
}
export type CreateBillMutationHookResult = ReturnType<
  typeof useCreateBillMutation
>
export type CreateBillMutationResult = Apollo.MutationResult<CreateBillMutation>
export type CreateBillMutationOptions = Apollo.BaseMutationOptions<
  CreateBillMutation,
  CreateBillMutationVariables
>
export const UpdateBillDocument = gql`
  mutation UpdateBill($input: BillUpdateInput!) {
    billUpdate(input: $input) {
      record {
        ...BillFragment
      }
      errors {
        message
        path
      }
    }
  }
  ${BillFragmentFragmentDoc}
`
export type UpdateBillMutationFn = Apollo.MutationFunction<
  UpdateBillMutation,
  UpdateBillMutationVariables
>

/**
 * __useUpdateBillMutation__
 *
 * To run a mutation, you first call `useUpdateBillMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateBillMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateBillMutation, { data, loading, error }] = useUpdateBillMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateBillMutation(
  baseOptions?: Apollo.MutationHookOptions<
    UpdateBillMutation,
    UpdateBillMutationVariables
  >
) {
  return Apollo.useMutation<UpdateBillMutation, UpdateBillMutationVariables>(
    UpdateBillDocument,
    baseOptions
  )
}
export type UpdateBillMutationHookResult = ReturnType<
  typeof useUpdateBillMutation
>
export type UpdateBillMutationResult = Apollo.MutationResult<UpdateBillMutation>
export type UpdateBillMutationOptions = Apollo.BaseMutationOptions<
  UpdateBillMutation,
  UpdateBillMutationVariables
>
export const NextPaycheckQueryDocument = gql`
  query NextPaycheckQuery {
    profile {
      name
    }
  }
`

/**
 * __useNextPaycheckQueryQuery__
 *
 * To run a query within a React component, call `useNextPaycheckQueryQuery` and pass it any options that fit your needs.
 * When your component renders, `useNextPaycheckQueryQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useNextPaycheckQueryQuery({
 *   variables: {
 *   },
 * });
 */
export function useNextPaycheckQueryQuery(
  baseOptions?: Apollo.QueryHookOptions<
    NextPaycheckQueryQuery,
    NextPaycheckQueryQueryVariables
  >
) {
  return Apollo.useQuery<
    NextPaycheckQueryQuery,
    NextPaycheckQueryQueryVariables
  >(NextPaycheckQueryDocument, baseOptions)
}
export function useNextPaycheckQueryLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    NextPaycheckQueryQuery,
    NextPaycheckQueryQueryVariables
  >
) {
  return Apollo.useLazyQuery<
    NextPaycheckQueryQuery,
    NextPaycheckQueryQueryVariables
  >(NextPaycheckQueryDocument, baseOptions)
}
export type NextPaycheckQueryQueryHookResult = ReturnType<
  typeof useNextPaycheckQueryQuery
>
export type NextPaycheckQueryLazyQueryHookResult = ReturnType<
  typeof useNextPaycheckQueryLazyQuery
>
export type NextPaycheckQueryQueryResult = Apollo.QueryResult<
  NextPaycheckQueryQuery,
  NextPaycheckQueryQueryVariables
>
export const RoundUpActivateDocument = gql`
  mutation RoundUpActivate($id: ID!, $startAt: DateTime!, $startOn: Date) {
    roundUpSetStartTime(input: { id: $id, startAt: $startAt }) {
      success
      record {
        id
        balance(filter: { date_gte: $startOn }) {
          id
          available
        }
        transactionsConnection(filter: { date_gte: $startOn }) {
          nodes {
            id
            date
            amount
            description
          }
        }
      }
    }
  }
`

export type RoundUpActivateMutationFn = Apollo.MutationFunction<
  RoundUpActivateMutation,
  RoundUpActivateMutationVariables
>

/**
 * __useRoundUpActivateMutation__
 *
 * To run a mutation, you first call `useRoundUpActivateMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRoundUpActivateMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [roundUpActivateMutation, { data, loading, error }] = useRoundUpActivateMutation({
 *   variables: {
 *      id: // value for 'id'
 *      startAt: // value for 'startAt'
 *      startOn: // value for 'startOn'
 *   },
 * });
 */
export function useRoundUpActivateMutation(
  baseOptions?: Apollo.MutationHookOptions<
    RoundUpActivateMutation,
    RoundUpActivateMutationVariables
  >
) {
  return Apollo.useMutation<
    RoundUpActivateMutation,
    RoundUpActivateMutationVariables
  >(RoundUpActivateDocument, baseOptions)
}
export type RoundUpActivateMutationHookResult = ReturnType<
  typeof useRoundUpActivateMutation
>
export type RoundUpActivateMutationResult =
  Apollo.MutationResult<RoundUpActivateMutation>
export type RoundUpActivateMutationOptions = Apollo.BaseMutationOptions<
  RoundUpActivateMutation,
  RoundUpActivateMutationVariables
>
export const RoundUpActivateDateSearchDocument = gql`
  query RoundUpActivateDateSearch($id: ID!) {
    roundUp(id: $id) {
      id
      subscribedAccounts {
        id
        transactions(limit: 15, filter: { amount_lt: 0 }) {
          id
          date
          amount
          status
        }
      }
    }
  }
`

/**
 * __useRoundUpActivateDateSearchQuery__
 *
 * To run a query within a React component, call `useRoundUpActivateDateSearchQuery` and pass it any options that fit your needs.
 * When your component renders, `useRoundUpActivateDateSearchQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRoundUpActivateDateSearchQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useRoundUpActivateDateSearchQuery(
  baseOptions: Apollo.QueryHookOptions<
    RoundUpActivateDateSearchQuery,
    RoundUpActivateDateSearchQueryVariables
  >
) {
  return Apollo.useQuery<
    RoundUpActivateDateSearchQuery,
    RoundUpActivateDateSearchQueryVariables
  >(RoundUpActivateDateSearchDocument, baseOptions)
}
export function useRoundUpActivateDateSearchLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    RoundUpActivateDateSearchQuery,
    RoundUpActivateDateSearchQueryVariables
  >
) {
  return Apollo.useLazyQuery<
    RoundUpActivateDateSearchQuery,
    RoundUpActivateDateSearchQueryVariables
  >(RoundUpActivateDateSearchDocument, baseOptions)
}
export type RoundUpActivateDateSearchQueryHookResult = ReturnType<
  typeof useRoundUpActivateDateSearchQuery
>
export type RoundUpActivateDateSearchLazyQueryHookResult = ReturnType<
  typeof useRoundUpActivateDateSearchLazyQuery
>
export type RoundUpActivateDateSearchQueryResult = Apollo.QueryResult<
  RoundUpActivateDateSearchQuery,
  RoundUpActivateDateSearchQueryVariables
>
export const RoundUpsBankConnectionsAccountsListDocument = gql`
  query RoundUpsBankConnectionsAccountsList(
    $roundUpId: ID!
    $bankConnectionId: ID!
  ) {
    roundUp(id: $roundUpId) {
      id
      fundingAccount {
        id
      }
    }
    plaidItem(id: $bankConnectionId) {
      id
      name
      logo {
        url
      }
      accounts {
        id
        name
      }
      status
      syncedAt
    }
  }
`

/**
 * __useRoundUpsBankConnectionsAccountsListQuery__
 *
 * To run a query within a React component, call `useRoundUpsBankConnectionsAccountsListQuery` and pass it any options that fit your needs.
 * When your component renders, `useRoundUpsBankConnectionsAccountsListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRoundUpsBankConnectionsAccountsListQuery({
 *   variables: {
 *      roundUpId: // value for 'roundUpId'
 *      bankConnectionId: // value for 'bankConnectionId'
 *   },
 * });
 */
export function useRoundUpsBankConnectionsAccountsListQuery(
  baseOptions: Apollo.QueryHookOptions<
    RoundUpsBankConnectionsAccountsListQuery,
    RoundUpsBankConnectionsAccountsListQueryVariables
  >
) {
  return Apollo.useQuery<
    RoundUpsBankConnectionsAccountsListQuery,
    RoundUpsBankConnectionsAccountsListQueryVariables
  >(RoundUpsBankConnectionsAccountsListDocument, baseOptions)
}
export function useRoundUpsBankConnectionsAccountsListLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    RoundUpsBankConnectionsAccountsListQuery,
    RoundUpsBankConnectionsAccountsListQueryVariables
  >
) {
  return Apollo.useLazyQuery<
    RoundUpsBankConnectionsAccountsListQuery,
    RoundUpsBankConnectionsAccountsListQueryVariables
  >(RoundUpsBankConnectionsAccountsListDocument, baseOptions)
}
export type RoundUpsBankConnectionsAccountsListQueryHookResult = ReturnType<
  typeof useRoundUpsBankConnectionsAccountsListQuery
>
export type RoundUpsBankConnectionsAccountsListLazyQueryHookResult = ReturnType<
  typeof useRoundUpsBankConnectionsAccountsListLazyQuery
>
export type RoundUpsBankConnectionsAccountsListQueryResult = Apollo.QueryResult<
  RoundUpsBankConnectionsAccountsListQuery,
  RoundUpsBankConnectionsAccountsListQueryVariables
>
export const RoundUpsBankConnectionsAccountsListItemDocument = gql`
  query RoundUpsBankConnectionsAccountsListItem(
    $roundUpId: ID!
    $accountId: ID!
  ) {
    roundUp(id: $roundUpId) {
      id
      fundingAccount {
        id
      }
      subscribedAccounts {
        id
      }
      availableAccounts {
        id
      }
    }
    account(id: $accountId) {
      id
      name
      lastFourDigits
    }
  }
`

/**
 * __useRoundUpsBankConnectionsAccountsListItemQuery__
 *
 * To run a query within a React component, call `useRoundUpsBankConnectionsAccountsListItemQuery` and pass it any options that fit your needs.
 * When your component renders, `useRoundUpsBankConnectionsAccountsListItemQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRoundUpsBankConnectionsAccountsListItemQuery({
 *   variables: {
 *      roundUpId: // value for 'roundUpId'
 *      accountId: // value for 'accountId'
 *   },
 * });
 */
export function useRoundUpsBankConnectionsAccountsListItemQuery(
  baseOptions: Apollo.QueryHookOptions<
    RoundUpsBankConnectionsAccountsListItemQuery,
    RoundUpsBankConnectionsAccountsListItemQueryVariables
  >
) {
  return Apollo.useQuery<
    RoundUpsBankConnectionsAccountsListItemQuery,
    RoundUpsBankConnectionsAccountsListItemQueryVariables
  >(RoundUpsBankConnectionsAccountsListItemDocument, baseOptions)
}
export function useRoundUpsBankConnectionsAccountsListItemLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    RoundUpsBankConnectionsAccountsListItemQuery,
    RoundUpsBankConnectionsAccountsListItemQueryVariables
  >
) {
  return Apollo.useLazyQuery<
    RoundUpsBankConnectionsAccountsListItemQuery,
    RoundUpsBankConnectionsAccountsListItemQueryVariables
  >(RoundUpsBankConnectionsAccountsListItemDocument, baseOptions)
}
export type RoundUpsBankConnectionsAccountsListItemQueryHookResult = ReturnType<
  typeof useRoundUpsBankConnectionsAccountsListItemQuery
>
export type RoundUpsBankConnectionsAccountsListItemLazyQueryHookResult =
  ReturnType<typeof useRoundUpsBankConnectionsAccountsListItemLazyQuery>
export type RoundUpsBankConnectionsAccountsListItemQueryResult =
  Apollo.QueryResult<
    RoundUpsBankConnectionsAccountsListItemQuery,
    RoundUpsBankConnectionsAccountsListItemQueryVariables
  >
export const RoundUpsAccountsSubscribeDocument = gql`
  mutation RoundUpsAccountsSubscribe($id: ID!, $accountId: ID!) {
    roundUpSubscribedAccountsAdd(input: { id: $id, accountIds: [$accountId] }) {
      record {
        id
        subscribedAccounts {
          id
        }
        availableAccounts {
          id
        }
      }
    }
  }
`
export type RoundUpsAccountsSubscribeMutationFn = Apollo.MutationFunction<
  RoundUpsAccountsSubscribeMutation,
  RoundUpsAccountsSubscribeMutationVariables
>

/**
 * __useRoundUpsAccountsSubscribeMutation__
 *
 * To run a mutation, you first call `useRoundUpsAccountsSubscribeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRoundUpsAccountsSubscribeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [roundUpsAccountsSubscribeMutation, { data, loading, error }] = useRoundUpsAccountsSubscribeMutation({
 *   variables: {
 *      id: // value for 'id'
 *      accountId: // value for 'accountId'
 *   },
 * });
 */
export function useRoundUpsAccountsSubscribeMutation(
  baseOptions?: Apollo.MutationHookOptions<
    RoundUpsAccountsSubscribeMutation,
    RoundUpsAccountsSubscribeMutationVariables
  >
) {
  return Apollo.useMutation<
    RoundUpsAccountsSubscribeMutation,
    RoundUpsAccountsSubscribeMutationVariables
  >(RoundUpsAccountsSubscribeDocument, baseOptions)
}
export type RoundUpsAccountsSubscribeMutationHookResult = ReturnType<
  typeof useRoundUpsAccountsSubscribeMutation
>
export type RoundUpsAccountsSubscribeMutationResult =
  Apollo.MutationResult<RoundUpsAccountsSubscribeMutation>
export type RoundUpsAccountsSubscribeMutationOptions =
  Apollo.BaseMutationOptions<
    RoundUpsAccountsSubscribeMutation,
    RoundUpsAccountsSubscribeMutationVariables
  >
export const RoundUpsAccountsUnsubscribeDocument = gql`
  mutation RoundUpsAccountsUnsubscribe($id: ID!, $accountId: ID!) {
    roundUpSubscribedAccountsRemove(
      input: { id: $id, accountIds: [$accountId] }
    ) {
      record {
        id
        subscribedAccounts {
          id
        }
        availableAccounts {
          id
        }
      }
    }
  }
`
export type RoundUpsAccountsUnsubscribeMutationFn = Apollo.MutationFunction<
  RoundUpsAccountsUnsubscribeMutation,
  RoundUpsAccountsUnsubscribeMutationVariables
>

/**
 * __useRoundUpsAccountsUnsubscribeMutation__
 *
 * To run a mutation, you first call `useRoundUpsAccountsUnsubscribeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRoundUpsAccountsUnsubscribeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [roundUpsAccountsUnsubscribeMutation, { data, loading, error }] = useRoundUpsAccountsUnsubscribeMutation({
 *   variables: {
 *      id: // value for 'id'
 *      accountId: // value for 'accountId'
 *   },
 * });
 */
export function useRoundUpsAccountsUnsubscribeMutation(
  baseOptions?: Apollo.MutationHookOptions<
    RoundUpsAccountsUnsubscribeMutation,
    RoundUpsAccountsUnsubscribeMutationVariables
  >
) {
  return Apollo.useMutation<
    RoundUpsAccountsUnsubscribeMutation,
    RoundUpsAccountsUnsubscribeMutationVariables
  >(RoundUpsAccountsUnsubscribeDocument, baseOptions)
}
export type RoundUpsAccountsUnsubscribeMutationHookResult = ReturnType<
  typeof useRoundUpsAccountsUnsubscribeMutation
>
export type RoundUpsAccountsUnsubscribeMutationResult =
  Apollo.MutationResult<RoundUpsAccountsUnsubscribeMutation>
export type RoundUpsAccountsUnsubscribeMutationOptions =
  Apollo.BaseMutationOptions<
    RoundUpsAccountsUnsubscribeMutation,
    RoundUpsAccountsUnsubscribeMutationVariables
  >
export const RoundUpsBankConnectionsAddFundingDocument = gql`
  mutation RoundUpsBankConnectionsAddFunding(
    $roundUpId: ID!
    $publicToken: String!
    $metadata: JSON!
    $accountId: ID!
  ) {
    plaidItemCreate(
      input: {
        publicToken: $publicToken
        metadata: $metadata
        accountIds: [$accountId]
      }
    ) {
      success
      record {
        id
      }
    }
    roundUpSetFundingAccount(input: { id: $roundUpId, accountId: $accountId }) {
      success
      record {
        id
      }
    }
    roundUpSubscribedAccountsAdd(
      input: { id: $roundUpId, accountIds: [$accountId] }
    ) {
      success
      record {
        id
      }
    }
  }
`
export type RoundUpsBankConnectionsAddFundingMutationFn =
  Apollo.MutationFunction<
    RoundUpsBankConnectionsAddFundingMutation,
    RoundUpsBankConnectionsAddFundingMutationVariables
  >

/**
 * __useRoundUpsBankConnectionsAddFundingMutation__
 *
 * To run a mutation, you first call `useRoundUpsBankConnectionsAddFundingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRoundUpsBankConnectionsAddFundingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [roundUpsBankConnectionsAddFundingMutation, { data, loading, error }] = useRoundUpsBankConnectionsAddFundingMutation({
 *   variables: {
 *      roundUpId: // value for 'roundUpId'
 *      publicToken: // value for 'publicToken'
 *      metadata: // value for 'metadata'
 *      accountId: // value for 'accountId'
 *   },
 * });
 */
export function useRoundUpsBankConnectionsAddFundingMutation(
  baseOptions?: Apollo.MutationHookOptions<
    RoundUpsBankConnectionsAddFundingMutation,
    RoundUpsBankConnectionsAddFundingMutationVariables
  >
) {
  return Apollo.useMutation<
    RoundUpsBankConnectionsAddFundingMutation,
    RoundUpsBankConnectionsAddFundingMutationVariables
  >(RoundUpsBankConnectionsAddFundingDocument, baseOptions)
}
export type RoundUpsBankConnectionsAddFundingMutationHookResult = ReturnType<
  typeof useRoundUpsBankConnectionsAddFundingMutation
>
export type RoundUpsBankConnectionsAddFundingMutationResult =
  Apollo.MutationResult<RoundUpsBankConnectionsAddFundingMutation>
export type RoundUpsBankConnectionsAddFundingMutationOptions =
  Apollo.BaseMutationOptions<
    RoundUpsBankConnectionsAddFundingMutation,
    RoundUpsBankConnectionsAddFundingMutationVariables
  >
export const RoundUpsBankConnectionsAddSubscriptionDocument = gql`
  mutation RoundUpsBankConnectionsAddSubscription(
    $roundUpId: ID!
    $publicToken: String!
    $metadata: JSON!
    $accountIds: [ID!]!
  ) {
    plaidItemCreate(
      input: {
        publicToken: $publicToken
        metadata: $metadata
        accountIds: $accountIds
      }
    ) {
      success
      record {
        ...PlaidItemFragment
      }
    }
    roundUpSubscribedAccountsAdd(
      input: { id: $roundUpId, accountIds: $accountIds }
    ) {
      success
      record {
        id
      }
    }
  }
  ${PlaidItemFragmentFragmentDoc}
`
export type RoundUpsBankConnectionsAddSubscriptionMutationFn =
  Apollo.MutationFunction<
    RoundUpsBankConnectionsAddSubscriptionMutation,
    RoundUpsBankConnectionsAddSubscriptionMutationVariables
  >

/**
 * __useRoundUpsBankConnectionsAddSubscriptionMutation__
 *
 * To run a mutation, you first call `useRoundUpsBankConnectionsAddSubscriptionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRoundUpsBankConnectionsAddSubscriptionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [roundUpsBankConnectionsAddSubscriptionMutation, { data, loading, error }] = useRoundUpsBankConnectionsAddSubscriptionMutation({
 *   variables: {
 *      roundUpId: // value for 'roundUpId'
 *      publicToken: // value for 'publicToken'
 *      metadata: // value for 'metadata'
 *      accountIds: // value for 'accountIds'
 *   },
 * });
 */
export function useRoundUpsBankConnectionsAddSubscriptionMutation(
  baseOptions?: Apollo.MutationHookOptions<
    RoundUpsBankConnectionsAddSubscriptionMutation,
    RoundUpsBankConnectionsAddSubscriptionMutationVariables
  >
) {
  return Apollo.useMutation<
    RoundUpsBankConnectionsAddSubscriptionMutation,
    RoundUpsBankConnectionsAddSubscriptionMutationVariables
  >(RoundUpsBankConnectionsAddSubscriptionDocument, baseOptions)
}
export type RoundUpsBankConnectionsAddSubscriptionMutationHookResult =
  ReturnType<typeof useRoundUpsBankConnectionsAddSubscriptionMutation>
export type RoundUpsBankConnectionsAddSubscriptionMutationResult =
  Apollo.MutationResult<RoundUpsBankConnectionsAddSubscriptionMutation>
export type RoundUpsBankConnectionsAddSubscriptionMutationOptions =
  Apollo.BaseMutationOptions<
    RoundUpsBankConnectionsAddSubscriptionMutation,
    RoundUpsBankConnectionsAddSubscriptionMutationVariables
  >
export const RoundUpsRecentActivityDocument = gql`
  query RoundUpsRecentActivity($roundUpId: ID!, $since: Date!) {
    roundUp(id: $roundUpId) {
      id
      recentActivity: balance(filter: { date_gte: $since }) {
        id
        current
      }
    }
  }
`

/**
 * __useRoundUpsRecentActivityQuery__
 *
 * To run a query within a React component, call `useRoundUpsRecentActivityQuery` and pass it any options that fit your needs.
 * When your component renders, `useRoundUpsRecentActivityQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRoundUpsRecentActivityQuery({
 *   variables: {
 *      roundUpId: // value for 'roundUpId'
 *      since: // value for 'since'
 *   },
 * });
 */
export function useRoundUpsRecentActivityQuery(
  baseOptions: Apollo.QueryHookOptions<
    RoundUpsRecentActivityQuery,
    RoundUpsRecentActivityQueryVariables
  >
) {
  return Apollo.useQuery<
    RoundUpsRecentActivityQuery,
    RoundUpsRecentActivityQueryVariables
  >(RoundUpsRecentActivityDocument, baseOptions)
}
export function useRoundUpsRecentActivityLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    RoundUpsRecentActivityQuery,
    RoundUpsRecentActivityQueryVariables
  >
) {
  return Apollo.useLazyQuery<
    RoundUpsRecentActivityQuery,
    RoundUpsRecentActivityQueryVariables
  >(RoundUpsRecentActivityDocument, baseOptions)
}
export type RoundUpsRecentActivityQueryHookResult = ReturnType<
  typeof useRoundUpsRecentActivityQuery
>
export type RoundUpsRecentActivityLazyQueryHookResult = ReturnType<
  typeof useRoundUpsRecentActivityLazyQuery
>
export type RoundUpsRecentActivityQueryResult = Apollo.QueryResult<
  RoundUpsRecentActivityQuery,
  RoundUpsRecentActivityQueryVariables
>
export const RoundUpsBankConnectionsSummaryCardFooterDocument = gql`
  query RoundUpsBankConnectionsSummaryCardFooter($id: ID!) {
    roundUp(id: $id) {
      id
      fundingAccount {
        id
      }
    }
  }
`

/**
 * __useRoundUpsBankConnectionsSummaryCardFooterQuery__
 *
 * To run a query within a React component, call `useRoundUpsBankConnectionsSummaryCardFooterQuery` and pass it any options that fit your needs.
 * When your component renders, `useRoundUpsBankConnectionsSummaryCardFooterQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRoundUpsBankConnectionsSummaryCardFooterQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useRoundUpsBankConnectionsSummaryCardFooterQuery(
  baseOptions: Apollo.QueryHookOptions<
    RoundUpsBankConnectionsSummaryCardFooterQuery,
    RoundUpsBankConnectionsSummaryCardFooterQueryVariables
  >
) {
  return Apollo.useQuery<
    RoundUpsBankConnectionsSummaryCardFooterQuery,
    RoundUpsBankConnectionsSummaryCardFooterQueryVariables
  >(RoundUpsBankConnectionsSummaryCardFooterDocument, baseOptions)
}
export function useRoundUpsBankConnectionsSummaryCardFooterLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    RoundUpsBankConnectionsSummaryCardFooterQuery,
    RoundUpsBankConnectionsSummaryCardFooterQueryVariables
  >
) {
  return Apollo.useLazyQuery<
    RoundUpsBankConnectionsSummaryCardFooterQuery,
    RoundUpsBankConnectionsSummaryCardFooterQueryVariables
  >(RoundUpsBankConnectionsSummaryCardFooterDocument, baseOptions)
}
export type RoundUpsBankConnectionsSummaryCardFooterQueryHookResult =
  ReturnType<typeof useRoundUpsBankConnectionsSummaryCardFooterQuery>
export type RoundUpsBankConnectionsSummaryCardFooterLazyQueryHookResult =
  ReturnType<typeof useRoundUpsBankConnectionsSummaryCardFooterLazyQuery>
export type RoundUpsBankConnectionsSummaryCardFooterQueryResult =
  Apollo.QueryResult<
    RoundUpsBankConnectionsSummaryCardFooterQuery,
    RoundUpsBankConnectionsSummaryCardFooterQueryVariables
  >
export const RoundUpsBankConnectionsSummaryCardHeaderDocument = gql`
  query RoundUpsBankConnectionsSummaryCardHeader {
    plaidItems {
      id
    }
  }
`

/**
 * __useRoundUpsBankConnectionsSummaryCardHeaderQuery__
 *
 * To run a query within a React component, call `useRoundUpsBankConnectionsSummaryCardHeaderQuery` and pass it any options that fit your needs.
 * When your component renders, `useRoundUpsBankConnectionsSummaryCardHeaderQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRoundUpsBankConnectionsSummaryCardHeaderQuery({
 *   variables: {
 *   },
 * });
 */
export function useRoundUpsBankConnectionsSummaryCardHeaderQuery(
  baseOptions?: Apollo.QueryHookOptions<
    RoundUpsBankConnectionsSummaryCardHeaderQuery,
    RoundUpsBankConnectionsSummaryCardHeaderQueryVariables
  >
) {
  return Apollo.useQuery<
    RoundUpsBankConnectionsSummaryCardHeaderQuery,
    RoundUpsBankConnectionsSummaryCardHeaderQueryVariables
  >(RoundUpsBankConnectionsSummaryCardHeaderDocument, baseOptions)
}
export function useRoundUpsBankConnectionsSummaryCardHeaderLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    RoundUpsBankConnectionsSummaryCardHeaderQuery,
    RoundUpsBankConnectionsSummaryCardHeaderQueryVariables
  >
) {
  return Apollo.useLazyQuery<
    RoundUpsBankConnectionsSummaryCardHeaderQuery,
    RoundUpsBankConnectionsSummaryCardHeaderQueryVariables
  >(RoundUpsBankConnectionsSummaryCardHeaderDocument, baseOptions)
}
export type RoundUpsBankConnectionsSummaryCardHeaderQueryHookResult =
  ReturnType<typeof useRoundUpsBankConnectionsSummaryCardHeaderQuery>
export type RoundUpsBankConnectionsSummaryCardHeaderLazyQueryHookResult =
  ReturnType<typeof useRoundUpsBankConnectionsSummaryCardHeaderLazyQuery>
export type RoundUpsBankConnectionsSummaryCardHeaderQueryResult =
  Apollo.QueryResult<
    RoundUpsBankConnectionsSummaryCardHeaderQuery,
    RoundUpsBankConnectionsSummaryCardHeaderQueryVariables
  >
export const RoundUpsBankConnectionsCardDocument = gql`
  query RoundUpsBankConnectionsCard($roundUpId: ID!, $id: ID!) {
    roundUp(id: $roundUpId) {
      id
    }
    plaidItem(id: $id) {
      id
      name
      logo {
        url
      }
    }
  }
`

/**
 * __useRoundUpsBankConnectionsCardQuery__
 *
 * To run a query within a React component, call `useRoundUpsBankConnectionsCardQuery` and pass it any options that fit your needs.
 * When your component renders, `useRoundUpsBankConnectionsCardQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRoundUpsBankConnectionsCardQuery({
 *   variables: {
 *      roundUpId: // value for 'roundUpId'
 *      id: // value for 'id'
 *   },
 * });
 */
export function useRoundUpsBankConnectionsCardQuery(
  baseOptions: Apollo.QueryHookOptions<
    RoundUpsBankConnectionsCardQuery,
    RoundUpsBankConnectionsCardQueryVariables
  >
) {
  return Apollo.useQuery<
    RoundUpsBankConnectionsCardQuery,
    RoundUpsBankConnectionsCardQueryVariables
  >(RoundUpsBankConnectionsCardDocument, baseOptions)
}
export function useRoundUpsBankConnectionsCardLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    RoundUpsBankConnectionsCardQuery,
    RoundUpsBankConnectionsCardQueryVariables
  >
) {
  return Apollo.useLazyQuery<
    RoundUpsBankConnectionsCardQuery,
    RoundUpsBankConnectionsCardQueryVariables
  >(RoundUpsBankConnectionsCardDocument, baseOptions)
}
export type RoundUpsBankConnectionsCardQueryHookResult = ReturnType<
  typeof useRoundUpsBankConnectionsCardQuery
>
export type RoundUpsBankConnectionsCardLazyQueryHookResult = ReturnType<
  typeof useRoundUpsBankConnectionsCardLazyQuery
>
export type RoundUpsBankConnectionsCardQueryResult = Apollo.QueryResult<
  RoundUpsBankConnectionsCardQuery,
  RoundUpsBankConnectionsCardQueryVariables
>
export const RoundUpsBankConnectionsListDocument = gql`
  query RoundUpsBankConnectionsList($roundUpId: ID!) {
    roundUp(id: $roundUpId) {
      id
      fundingAccount {
        ...AccountFragment
      }
    }
    plaidItems {
      id
      name
      logo {
        url
      }
      status
      syncedAt
    }
  }
  ${AccountFragmentFragmentDoc}
`

/**
 * __useRoundUpsBankConnectionsListQuery__
 *
 * To run a query within a React component, call `useRoundUpsBankConnectionsListQuery` and pass it any options that fit your needs.
 * When your component renders, `useRoundUpsBankConnectionsListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRoundUpsBankConnectionsListQuery({
 *   variables: {
 *      roundUpId: // value for 'roundUpId'
 *   },
 * });
 */
export function useRoundUpsBankConnectionsListQuery(
  baseOptions: Apollo.QueryHookOptions<
    RoundUpsBankConnectionsListQuery,
    RoundUpsBankConnectionsListQueryVariables
  >
) {
  return Apollo.useQuery<
    RoundUpsBankConnectionsListQuery,
    RoundUpsBankConnectionsListQueryVariables
  >(RoundUpsBankConnectionsListDocument, baseOptions)
}
export function useRoundUpsBankConnectionsListLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    RoundUpsBankConnectionsListQuery,
    RoundUpsBankConnectionsListQueryVariables
  >
) {
  return Apollo.useLazyQuery<
    RoundUpsBankConnectionsListQuery,
    RoundUpsBankConnectionsListQueryVariables
  >(RoundUpsBankConnectionsListDocument, baseOptions)
}
export type RoundUpsBankConnectionsListQueryHookResult = ReturnType<
  typeof useRoundUpsBankConnectionsListQuery
>
export type RoundUpsBankConnectionsListLazyQueryHookResult = ReturnType<
  typeof useRoundUpsBankConnectionsListLazyQuery
>
export type RoundUpsBankConnectionsListQueryResult = Apollo.QueryResult<
  RoundUpsBankConnectionsListQuery,
  RoundUpsBankConnectionsListQueryVariables
>
export const RoundUpsBankConnectionsListItemDocument = gql`
  query RoundUpsBankConnectionsListItem($roundUpId: ID!, $id: ID!) {
    roundUp(id: $roundUpId) {
      id
      fundingAccount {
        ...AccountFragment
      }
    }
    plaidItem(id: $id) {
      id
      name
      logo {
        url
      }
      status
      syncedAt
    }
  }
  ${AccountFragmentFragmentDoc}
`

/**
 * __useRoundUpsBankConnectionsListItemQuery__
 *
 * To run a query within a React component, call `useRoundUpsBankConnectionsListItemQuery` and pass it any options that fit your needs.
 * When your component renders, `useRoundUpsBankConnectionsListItemQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRoundUpsBankConnectionsListItemQuery({
 *   variables: {
 *      roundUpId: // value for 'roundUpId'
 *      id: // value for 'id'
 *   },
 * });
 */
export function useRoundUpsBankConnectionsListItemQuery(
  baseOptions: Apollo.QueryHookOptions<
    RoundUpsBankConnectionsListItemQuery,
    RoundUpsBankConnectionsListItemQueryVariables
  >
) {
  return Apollo.useQuery<
    RoundUpsBankConnectionsListItemQuery,
    RoundUpsBankConnectionsListItemQueryVariables
  >(RoundUpsBankConnectionsListItemDocument, baseOptions)
}
export function useRoundUpsBankConnectionsListItemLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    RoundUpsBankConnectionsListItemQuery,
    RoundUpsBankConnectionsListItemQueryVariables
  >
) {
  return Apollo.useLazyQuery<
    RoundUpsBankConnectionsListItemQuery,
    RoundUpsBankConnectionsListItemQueryVariables
  >(RoundUpsBankConnectionsListItemDocument, baseOptions)
}
export type RoundUpsBankConnectionsListItemQueryHookResult = ReturnType<
  typeof useRoundUpsBankConnectionsListItemQuery
>
export type RoundUpsBankConnectionsListItemLazyQueryHookResult = ReturnType<
  typeof useRoundUpsBankConnectionsListItemLazyQuery
>
export type RoundUpsBankConnectionsListItemQueryResult = Apollo.QueryResult<
  RoundUpsBankConnectionsListItemQuery,
  RoundUpsBankConnectionsListItemQueryVariables
>
export const RoundUpsBankConnectionsPageDocument = gql`
  query RoundUpsBankConnectionsPage($id: ID!) {
    roundUp(id: $id) {
      id
      fundingAccount {
        id
      }
    }
    plaidItems {
      id
      accounts {
        id
      }
    }
  }
`

/**
 * __useRoundUpsBankConnectionsPageQuery__
 *
 * To run a query within a React component, call `useRoundUpsBankConnectionsPageQuery` and pass it any options that fit your needs.
 * When your component renders, `useRoundUpsBankConnectionsPageQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRoundUpsBankConnectionsPageQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useRoundUpsBankConnectionsPageQuery(
  baseOptions: Apollo.QueryHookOptions<
    RoundUpsBankConnectionsPageQuery,
    RoundUpsBankConnectionsPageQueryVariables
  >
) {
  return Apollo.useQuery<
    RoundUpsBankConnectionsPageQuery,
    RoundUpsBankConnectionsPageQueryVariables
  >(RoundUpsBankConnectionsPageDocument, baseOptions)
}
export function useRoundUpsBankConnectionsPageLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    RoundUpsBankConnectionsPageQuery,
    RoundUpsBankConnectionsPageQueryVariables
  >
) {
  return Apollo.useLazyQuery<
    RoundUpsBankConnectionsPageQuery,
    RoundUpsBankConnectionsPageQueryVariables
  >(RoundUpsBankConnectionsPageDocument, baseOptions)
}
export type RoundUpsBankConnectionsPageQueryHookResult = ReturnType<
  typeof useRoundUpsBankConnectionsPageQuery
>
export type RoundUpsBankConnectionsPageLazyQueryHookResult = ReturnType<
  typeof useRoundUpsBankConnectionsPageLazyQuery
>
export type RoundUpsBankConnectionsPageQueryResult = Apollo.QueryResult<
  RoundUpsBankConnectionsPageQuery,
  RoundUpsBankConnectionsPageQueryVariables
>
export const RoundUpsPauseDocument = gql`
  mutation RoundUpsPause($id: ID!) {
    roundUpPause(input: { id: $id }) {
      record {
        id
        status
      }
    }
  }
`
export type RoundUpsPauseMutationFn = Apollo.MutationFunction<
  RoundUpsPauseMutation,
  RoundUpsPauseMutationVariables
>

/**
 * __useRoundUpsPauseMutation__
 *
 * To run a mutation, you first call `useRoundUpsPauseMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRoundUpsPauseMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [roundUpsPauseMutation, { data, loading, error }] = useRoundUpsPauseMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useRoundUpsPauseMutation(
  baseOptions?: Apollo.MutationHookOptions<
    RoundUpsPauseMutation,
    RoundUpsPauseMutationVariables
  >
) {
  return Apollo.useMutation<
    RoundUpsPauseMutation,
    RoundUpsPauseMutationVariables
  >(RoundUpsPauseDocument, baseOptions)
}
export type RoundUpsPauseMutationHookResult = ReturnType<
  typeof useRoundUpsPauseMutation
>
export type RoundUpsPauseMutationResult =
  Apollo.MutationResult<RoundUpsPauseMutation>
export type RoundUpsPauseMutationOptions = Apollo.BaseMutationOptions<
  RoundUpsPauseMutation,
  RoundUpsPauseMutationVariables
>
export const RoundUpsResumeDocument = gql`
  mutation RoundUpsResume($id: ID!) {
    roundUpResume(input: { id: $id }) {
      record {
        id
        status
      }
    }
  }
`
export type RoundUpsResumeMutationFn = Apollo.MutationFunction<
  RoundUpsResumeMutation,
  RoundUpsResumeMutationVariables
>

/**
 * __useRoundUpsResumeMutation__
 *
 * To run a mutation, you first call `useRoundUpsResumeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRoundUpsResumeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [roundUpsResumeMutation, { data, loading, error }] = useRoundUpsResumeMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useRoundUpsResumeMutation(
  baseOptions?: Apollo.MutationHookOptions<
    RoundUpsResumeMutation,
    RoundUpsResumeMutationVariables
  >
) {
  return Apollo.useMutation<
    RoundUpsResumeMutation,
    RoundUpsResumeMutationVariables
  >(RoundUpsResumeDocument, baseOptions)
}
export type RoundUpsResumeMutationHookResult = ReturnType<
  typeof useRoundUpsResumeMutation
>
export type RoundUpsResumeMutationResult =
  Apollo.MutationResult<RoundUpsResumeMutation>
export type RoundUpsResumeMutationOptions = Apollo.BaseMutationOptions<
  RoundUpsResumeMutation,
  RoundUpsResumeMutationVariables
>
export const RoundUpSummaryDocument = gql`
  query RoundUpSummary($id: ID!, $startOfWeek: Date) {
    roundUp(id: $id) {
      id
      totalAmount: balance {
        id
        available
        current
      }
      thisWeek: balance(filter: { date_gte: $startOfWeek }) {
        id
        available
        current
      }
    }
  }
`

/**
 * __useRoundUpSummaryQuery__
 *
 * To run a query within a React component, call `useRoundUpSummaryQuery` and pass it any options that fit your needs.
 * When your component renders, `useRoundUpSummaryQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRoundUpSummaryQuery({
 *   variables: {
 *      id: // value for 'id'
 *      startOfWeek: // value for 'startOfWeek'
 *   },
 * });
 */
export function useRoundUpSummaryQuery(
  baseOptions: Apollo.QueryHookOptions<
    RoundUpSummaryQuery,
    RoundUpSummaryQueryVariables
  >
) {
  return Apollo.useQuery<RoundUpSummaryQuery, RoundUpSummaryQueryVariables>(
    RoundUpSummaryDocument,
    baseOptions
  )
}
export function useRoundUpSummaryLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    RoundUpSummaryQuery,
    RoundUpSummaryQueryVariables
  >
) {
  return Apollo.useLazyQuery<RoundUpSummaryQuery, RoundUpSummaryQueryVariables>(
    RoundUpSummaryDocument,
    baseOptions
  )
}
export type RoundUpSummaryQueryHookResult = ReturnType<
  typeof useRoundUpSummaryQuery
>
export type RoundUpSummaryLazyQueryHookResult = ReturnType<
  typeof useRoundUpSummaryLazyQuery
>
export type RoundUpSummaryQueryResult = Apollo.QueryResult<
  RoundUpSummaryQuery,
  RoundUpSummaryQueryVariables
>
export const RoundUpHistoryDocument = gql`
  query RoundUpHistory(
    $id: ID!
    $day0: Date!
    $day1: Date!
    $day2: Date!
    $day3: Date!
    $day4: Date!
    $day5: Date!
    $day6: Date!
  ) {
    roundUp(id: $id) {
      id
      day0: balance(filter: { date_gte: $day0 }) {
        id
        available
      }
      day1: balance(filter: { date_lt: $day0, date_gte: $day1 }) {
        id
        available
      }
      day2: balance(filter: { date_lt: $day1, date_gte: $day2 }) {
        id
        available
      }
      day3: balance(filter: { date_lt: $day2, date_gte: $day3 }) {
        id
        available
      }
      day4: balance(filter: { date_lt: $day3, date_gte: $day4 }) {
        id
        available
      }
      day5: balance(filter: { date_lt: $day4, date_gte: $day5 }) {
        id
        available
      }
      day6: balance(filter: { date_lt: $day5, date_gte: $day6 }) {
        id
        available
      }
    }
  }
`

/**
 * __useRoundUpHistoryQuery__
 *
 * To run a query within a React component, call `useRoundUpHistoryQuery` and pass it any options that fit your needs.
 * When your component renders, `useRoundUpHistoryQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRoundUpHistoryQuery({
 *   variables: {
 *      id: // value for 'id'
 *      day0: // value for 'day0'
 *      day1: // value for 'day1'
 *      day2: // value for 'day2'
 *      day3: // value for 'day3'
 *      day4: // value for 'day4'
 *      day5: // value for 'day5'
 *      day6: // value for 'day6'
 *   },
 * });
 */
export function useRoundUpHistoryQuery(
  baseOptions: Apollo.QueryHookOptions<
    RoundUpHistoryQuery,
    RoundUpHistoryQueryVariables
  >
) {
  return Apollo.useQuery<RoundUpHistoryQuery, RoundUpHistoryQueryVariables>(
    RoundUpHistoryDocument,
    baseOptions
  )
}
export function useRoundUpHistoryLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    RoundUpHistoryQuery,
    RoundUpHistoryQueryVariables
  >
) {
  return Apollo.useLazyQuery<RoundUpHistoryQuery, RoundUpHistoryQueryVariables>(
    RoundUpHistoryDocument,
    baseOptions
  )
}
export type RoundUpHistoryQueryHookResult = ReturnType<
  typeof useRoundUpHistoryQuery
>
export type RoundUpHistoryLazyQueryHookResult = ReturnType<
  typeof useRoundUpHistoryLazyQuery
>
export type RoundUpHistoryQueryResult = Apollo.QueryResult<
  RoundUpHistoryQuery,
  RoundUpHistoryQueryVariables
>
export const RoundUpTransactionsDocument = gql`
  query RoundUpTransactions($id: ID!) {
    roundUp(id: $id) {
      id
      transactionsConnection {
        edges {
          node {
            id
            date
            amount
            description
          }
        }
      }
    }
  }
`

/**
 * __useRoundUpTransactionsQuery__
 *
 * To run a query within a React component, call `useRoundUpTransactionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useRoundUpTransactionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRoundUpTransactionsQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useRoundUpTransactionsQuery(
  baseOptions: Apollo.QueryHookOptions<
    RoundUpTransactionsQuery,
    RoundUpTransactionsQueryVariables
  >
) {
  return Apollo.useQuery<
    RoundUpTransactionsQuery,
    RoundUpTransactionsQueryVariables
  >(RoundUpTransactionsDocument, baseOptions)
}
export function useRoundUpTransactionsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    RoundUpTransactionsQuery,
    RoundUpTransactionsQueryVariables
  >
) {
  return Apollo.useLazyQuery<
    RoundUpTransactionsQuery,
    RoundUpTransactionsQueryVariables
  >(RoundUpTransactionsDocument, baseOptions)
}
export type RoundUpTransactionsQueryHookResult = ReturnType<
  typeof useRoundUpTransactionsQuery
>
export type RoundUpTransactionsLazyQueryHookResult = ReturnType<
  typeof useRoundUpTransactionsLazyQuery
>
export type RoundUpTransactionsQueryResult = Apollo.QueryResult<
  RoundUpTransactionsQuery,
  RoundUpTransactionsQueryVariables
>
export const RoundUpsDocument = gql`
  query RoundUps {
    roundUps {
      id
    }
  }
`

/**
 * __useRoundUpsQuery__
 *
 * To run a query within a React component, call `useRoundUpsQuery` and pass it any options that fit your needs.
 * When your component renders, `useRoundUpsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRoundUpsQuery({
 *   variables: {
 *   },
 * });
 */
export function useRoundUpsQuery(
  baseOptions?: Apollo.QueryHookOptions<RoundUpsQuery, RoundUpsQueryVariables>
) {
  return Apollo.useQuery<RoundUpsQuery, RoundUpsQueryVariables>(
    RoundUpsDocument,
    baseOptions
  )
}
export function useRoundUpsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    RoundUpsQuery,
    RoundUpsQueryVariables
  >
) {
  return Apollo.useLazyQuery<RoundUpsQuery, RoundUpsQueryVariables>(
    RoundUpsDocument,
    baseOptions
  )
}
export type RoundUpsQueryHookResult = ReturnType<typeof useRoundUpsQuery>
export type RoundUpsLazyQueryHookResult = ReturnType<
  typeof useRoundUpsLazyQuery
>
export type RoundUpsQueryResult = Apollo.QueryResult<
  RoundUpsQuery,
  RoundUpsQueryVariables
>
export const RoundUpHomeDocument = gql`
  query RoundUpHome($id: ID!) {
    roundUp(id: $id) {
      id
      status
      fundingAccount {
        id
      }
    }
  }
`

/**
 * __useRoundUpHomeQuery__
 *
 * To run a query within a React component, call `useRoundUpHomeQuery` and pass it any options that fit your needs.
 * When your component renders, `useRoundUpHomeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRoundUpHomeQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useRoundUpHomeQuery(
  baseOptions: Apollo.QueryHookOptions<
    RoundUpHomeQuery,
    RoundUpHomeQueryVariables
  >
) {
  return Apollo.useQuery<RoundUpHomeQuery, RoundUpHomeQueryVariables>(
    RoundUpHomeDocument,
    baseOptions
  )
}
export function useRoundUpHomeLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    RoundUpHomeQuery,
    RoundUpHomeQueryVariables
  >
) {
  return Apollo.useLazyQuery<RoundUpHomeQuery, RoundUpHomeQueryVariables>(
    RoundUpHomeDocument,
    baseOptions
  )
}
export type RoundUpHomeQueryHookResult = ReturnType<typeof useRoundUpHomeQuery>
export type RoundUpHomeLazyQueryHookResult = ReturnType<
  typeof useRoundUpHomeLazyQuery
>
export type RoundUpHomeQueryResult = Apollo.QueryResult<
  RoundUpHomeQuery,
  RoundUpHomeQueryVariables
>
export const CreateRoundUpDocument = gql`
  mutation CreateRoundUp {
    roundUpCreate(input: {}) {
      success
      record {
        id
        status
      }
    }
  }
`
export type CreateRoundUpMutationFn = Apollo.MutationFunction<
  CreateRoundUpMutation,
  CreateRoundUpMutationVariables
>

/**
 * __useCreateRoundUpMutation__
 *
 * To run a mutation, you first call `useCreateRoundUpMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateRoundUpMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createRoundUpMutation, { data, loading, error }] = useCreateRoundUpMutation({
 *   variables: {
 *   },
 * });
 */
export function useCreateRoundUpMutation(
  baseOptions?: Apollo.MutationHookOptions<
    CreateRoundUpMutation,
    CreateRoundUpMutationVariables
  >
) {
  return Apollo.useMutation<
    CreateRoundUpMutation,
    CreateRoundUpMutationVariables
  >(CreateRoundUpDocument, baseOptions)
}
export type CreateRoundUpMutationHookResult = ReturnType<
  typeof useCreateRoundUpMutation
>
export type CreateRoundUpMutationResult =
  Apollo.MutationResult<CreateRoundUpMutation>
export type CreateRoundUpMutationOptions = Apollo.BaseMutationOptions<
  CreateRoundUpMutation,
  CreateRoundUpMutationVariables
>
export const PlaidItemsDocument = gql`
  query PlaidItems {
    plaidItems {
      ...PlaidItemFragment
    }
  }
  ${PlaidItemFragmentFragmentDoc}
`

/**
 * __usePlaidItemsQuery__
 *
 * To run a query within a React component, call `usePlaidItemsQuery` and pass it any options that fit your needs.
 * When your component renders, `usePlaidItemsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePlaidItemsQuery({
 *   variables: {
 *   },
 * });
 */
export function usePlaidItemsQuery(
  baseOptions?: Apollo.QueryHookOptions<
    PlaidItemsQuery,
    PlaidItemsQueryVariables
  >
) {
  return Apollo.useQuery<PlaidItemsQuery, PlaidItemsQueryVariables>(
    PlaidItemsDocument,
    baseOptions
  )
}
export function usePlaidItemsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    PlaidItemsQuery,
    PlaidItemsQueryVariables
  >
) {
  return Apollo.useLazyQuery<PlaidItemsQuery, PlaidItemsQueryVariables>(
    PlaidItemsDocument,
    baseOptions
  )
}
export type PlaidItemsQueryHookResult = ReturnType<typeof usePlaidItemsQuery>
export type PlaidItemsLazyQueryHookResult = ReturnType<
  typeof usePlaidItemsLazyQuery
>
export type PlaidItemsQueryResult = Apollo.QueryResult<
  PlaidItemsQuery,
  PlaidItemsQueryVariables
>
export const PlaidItemSyncStatusDocument = gql`
  query PlaidItemSyncStatus($id: ID!) {
    plaidItem(id: $id) {
      id
      status
      syncedAt
    }
  }
`

/**
 * __usePlaidItemSyncStatusQuery__
 *
 * To run a query within a React component, call `usePlaidItemSyncStatusQuery` and pass it any options that fit your needs.
 * When your component renders, `usePlaidItemSyncStatusQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePlaidItemSyncStatusQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function usePlaidItemSyncStatusQuery(
  baseOptions: Apollo.QueryHookOptions<
    PlaidItemSyncStatusQuery,
    PlaidItemSyncStatusQueryVariables
  >
) {
  return Apollo.useQuery<
    PlaidItemSyncStatusQuery,
    PlaidItemSyncStatusQueryVariables
  >(PlaidItemSyncStatusDocument, baseOptions)
}
export function usePlaidItemSyncStatusLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    PlaidItemSyncStatusQuery,
    PlaidItemSyncStatusQueryVariables
  >
) {
  return Apollo.useLazyQuery<
    PlaidItemSyncStatusQuery,
    PlaidItemSyncStatusQueryVariables
  >(PlaidItemSyncStatusDocument, baseOptions)
}
export type PlaidItemSyncStatusQueryHookResult = ReturnType<
  typeof usePlaidItemSyncStatusQuery
>
export type PlaidItemSyncStatusLazyQueryHookResult = ReturnType<
  typeof usePlaidItemSyncStatusLazyQuery
>
export type PlaidItemSyncStatusQueryResult = Apollo.QueryResult<
  PlaidItemSyncStatusQuery,
  PlaidItemSyncStatusQueryVariables
>
export const PlaidLinkTokenCreateDocument = gql`
  mutation PlaidLinkTokenCreate($input: PlaidLinkTokenCreateInput!) {
    plaidLinkTokenCreate(input: $input) {
      record {
        linkToken
        expiration
      }
      errors {
        code
        type
        message
        requestId
        displayMessage
      }
    }
  }
`
export type PlaidLinkTokenCreateMutationFn = Apollo.MutationFunction<
  PlaidLinkTokenCreateMutation,
  PlaidLinkTokenCreateMutationVariables
>

/**
 * __usePlaidLinkTokenCreateMutation__
 *
 * To run a mutation, you first call `usePlaidLinkTokenCreateMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `usePlaidLinkTokenCreateMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [plaidLinkTokenCreateMutation, { data, loading, error }] = usePlaidLinkTokenCreateMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function usePlaidLinkTokenCreateMutation(
  baseOptions?: Apollo.MutationHookOptions<
    PlaidLinkTokenCreateMutation,
    PlaidLinkTokenCreateMutationVariables
  >
) {
  return Apollo.useMutation<
    PlaidLinkTokenCreateMutation,
    PlaidLinkTokenCreateMutationVariables
  >(PlaidLinkTokenCreateDocument, baseOptions)
}
export type PlaidLinkTokenCreateMutationHookResult = ReturnType<
  typeof usePlaidLinkTokenCreateMutation
>
export type PlaidLinkTokenCreateMutationResult =
  Apollo.MutationResult<PlaidLinkTokenCreateMutation>
export type PlaidLinkTokenCreateMutationOptions = Apollo.BaseMutationOptions<
  PlaidLinkTokenCreateMutation,
  PlaidLinkTokenCreateMutationVariables
>
export const PlaidLinkTokenCreateForUpdateDocument = gql`
  mutation PlaidLinkTokenCreateForUpdate(
    $input: PlaidLinkTokenCreateForUpdateInput!
  ) {
    plaidLinkTokenCreateForUpdate(input: $input) {
      record {
        linkToken
        expiration
      }
      errors {
        code
        type
        message
        requestId
        displayMessage
      }
    }
  }
`
export type PlaidLinkTokenCreateForUpdateMutationFn = Apollo.MutationFunction<
  PlaidLinkTokenCreateForUpdateMutation,
  PlaidLinkTokenCreateForUpdateMutationVariables
>

/**
 * __usePlaidLinkTokenCreateForUpdateMutation__
 *
 * To run a mutation, you first call `usePlaidLinkTokenCreateForUpdateMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `usePlaidLinkTokenCreateForUpdateMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [plaidLinkTokenCreateForUpdateMutation, { data, loading, error }] = usePlaidLinkTokenCreateForUpdateMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function usePlaidLinkTokenCreateForUpdateMutation(
  baseOptions?: Apollo.MutationHookOptions<
    PlaidLinkTokenCreateForUpdateMutation,
    PlaidLinkTokenCreateForUpdateMutationVariables
  >
) {
  return Apollo.useMutation<
    PlaidLinkTokenCreateForUpdateMutation,
    PlaidLinkTokenCreateForUpdateMutationVariables
  >(PlaidLinkTokenCreateForUpdateDocument, baseOptions)
}
export type PlaidLinkTokenCreateForUpdateMutationHookResult = ReturnType<
  typeof usePlaidLinkTokenCreateForUpdateMutation
>
export type PlaidLinkTokenCreateForUpdateMutationResult =
  Apollo.MutationResult<PlaidLinkTokenCreateForUpdateMutation>
export type PlaidLinkTokenCreateForUpdateMutationOptions =
  Apollo.BaseMutationOptions<
    PlaidLinkTokenCreateForUpdateMutation,
    PlaidLinkTokenCreateForUpdateMutationVariables
  >
export const PlaidItemCreateDocument = gql`
  mutation PlaidItemCreate($input: PlaidItemCreateInput!) {
    plaidItemCreate(input: $input) {
      record {
        ...PlaidItemFragment
      }
      errors {
        displayMessage
      }
    }
  }
  ${PlaidItemFragmentFragmentDoc}
`
export type PlaidItemCreateMutationFn = Apollo.MutationFunction<
  PlaidItemCreateMutation,
  PlaidItemCreateMutationVariables
>

/**
 * __usePlaidItemCreateMutation__
 *
 * To run a mutation, you first call `usePlaidItemCreateMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `usePlaidItemCreateMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [plaidItemCreateMutation, { data, loading, error }] = usePlaidItemCreateMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function usePlaidItemCreateMutation(
  baseOptions?: Apollo.MutationHookOptions<
    PlaidItemCreateMutation,
    PlaidItemCreateMutationVariables
  >
) {
  return Apollo.useMutation<
    PlaidItemCreateMutation,
    PlaidItemCreateMutationVariables
  >(PlaidItemCreateDocument, baseOptions)
}
export type PlaidItemCreateMutationHookResult = ReturnType<
  typeof usePlaidItemCreateMutation
>
export type PlaidItemCreateMutationResult =
  Apollo.MutationResult<PlaidItemCreateMutation>
export type PlaidItemCreateMutationOptions = Apollo.BaseMutationOptions<
  PlaidItemCreateMutation,
  PlaidItemCreateMutationVariables
>
export const PlaidItemUnlinkDocument = gql`
  mutation PlaidItemUnlink($id: ID!) {
    plaidItemDelete(input: { id: $id }) {
      success
      record {
        id
      }
    }
  }
`
export type PlaidItemUnlinkMutationFn = Apollo.MutationFunction<
  PlaidItemUnlinkMutation,
  PlaidItemUnlinkMutationVariables
>

/**
 * __usePlaidItemUnlinkMutation__
 *
 * To run a mutation, you first call `usePlaidItemUnlinkMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `usePlaidItemUnlinkMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [plaidItemUnlinkMutation, { data, loading, error }] = usePlaidItemUnlinkMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function usePlaidItemUnlinkMutation(
  baseOptions?: Apollo.MutationHookOptions<
    PlaidItemUnlinkMutation,
    PlaidItemUnlinkMutationVariables
  >
) {
  return Apollo.useMutation<
    PlaidItemUnlinkMutation,
    PlaidItemUnlinkMutationVariables
  >(PlaidItemUnlinkDocument, baseOptions)
}
export type PlaidItemUnlinkMutationHookResult = ReturnType<
  typeof usePlaidItemUnlinkMutation
>
export type PlaidItemUnlinkMutationResult =
  Apollo.MutationResult<PlaidItemUnlinkMutation>
export type PlaidItemUnlinkMutationOptions = Apollo.BaseMutationOptions<
  PlaidItemUnlinkMutation,
  PlaidItemUnlinkMutationVariables
>
export const PlaidItemUpdatedDocument = gql`
  subscription PlaidItemUpdated($id: ID!) {
    plaidItemUpdated(id: $id) {
      record {
        ...PlaidItemFragment
      }
    }
  }
  ${PlaidItemFragmentFragmentDoc}
`

/**
 * __usePlaidItemUpdatedSubscription__
 *
 * To run a query within a React component, call `usePlaidItemUpdatedSubscription` and pass it any options that fit your needs.
 * When your component renders, `usePlaidItemUpdatedSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePlaidItemUpdatedSubscription({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function usePlaidItemUpdatedSubscription(
  baseOptions: Apollo.SubscriptionHookOptions<
    PlaidItemUpdatedSubscription,
    PlaidItemUpdatedSubscriptionVariables
  >
) {
  return Apollo.useSubscription<
    PlaidItemUpdatedSubscription,
    PlaidItemUpdatedSubscriptionVariables
  >(PlaidItemUpdatedDocument, baseOptions)
}
export type PlaidItemUpdatedSubscriptionHookResult = ReturnType<
  typeof usePlaidItemUpdatedSubscription
>
export type PlaidItemUpdatedSubscriptionResult =
  Apollo.SubscriptionResult<PlaidItemUpdatedSubscription>
export const ProfileDocument = gql`
  query Profile {
    profile {
      ...ProfileFragment
    }
  }
  ${ProfileFragmentFragmentDoc}
`

/**
 * __useProfileQuery__
 *
 * To run a query within a React component, call `useProfileQuery` and pass it any options that fit your needs.
 * When your component renders, `useProfileQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useProfileQuery({
 *   variables: {
 *   },
 * });
 */
export function useProfileQuery(
  baseOptions?: Apollo.QueryHookOptions<ProfileQuery, ProfileQueryVariables>
) {
  return Apollo.useQuery<ProfileQuery, ProfileQueryVariables>(
    ProfileDocument,
    baseOptions
  )
}
export function useProfileLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<ProfileQuery, ProfileQueryVariables>
) {
  return Apollo.useLazyQuery<ProfileQuery, ProfileQueryVariables>(
    ProfileDocument,
    baseOptions
  )
}
export type ProfileQueryHookResult = ReturnType<typeof useProfileQuery>
export type ProfileLazyQueryHookResult = ReturnType<typeof useProfileLazyQuery>
export type ProfileQueryResult = Apollo.QueryResult<
  ProfileQuery,
  ProfileQueryVariables
>
export const ProfileUpdateDocument = gql`
  mutation ProfileUpdate($input: ProfileUpdateInput!) {
    profileUpdate(input: $input) {
      record {
        ...ProfileFragment
      }
      errors {
        path
        message
      }
    }
  }
  ${ProfileFragmentFragmentDoc}
`
export type ProfileUpdateMutationFn = Apollo.MutationFunction<
  ProfileUpdateMutation,
  ProfileUpdateMutationVariables
>

/**
 * __useProfileUpdateMutation__
 *
 * To run a mutation, you first call `useProfileUpdateMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useProfileUpdateMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [profileUpdateMutation, { data, loading, error }] = useProfileUpdateMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useProfileUpdateMutation(
  baseOptions?: Apollo.MutationHookOptions<
    ProfileUpdateMutation,
    ProfileUpdateMutationVariables
  >
) {
  return Apollo.useMutation<
    ProfileUpdateMutation,
    ProfileUpdateMutationVariables
  >(ProfileUpdateDocument, baseOptions)
}
export type ProfileUpdateMutationHookResult = ReturnType<
  typeof useProfileUpdateMutation
>
export type ProfileUpdateMutationResult =
  Apollo.MutationResult<ProfileUpdateMutation>
export type ProfileUpdateMutationOptions = Apollo.BaseMutationOptions<
  ProfileUpdateMutation,
  ProfileUpdateMutationVariables
>
